//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class Api {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    addSpot_Command(addSpotCommand: AddSpotCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AddSpotCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addSpotCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSpot_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSpot_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAddSpot_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeSpot_Command(removeSpotCommand: RemoveSpotCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RemoveSpotCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeSpotCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSpot_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSpot_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRemoveSpot_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    spotsOfRegistration_Query(spotsOfRegistrationQuery: SpotsOfRegistrationQuery | undefined): Observable<SpotDisplayItem[]> {
        let url_ = this.baseUrl + "/api/SpotsOfRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(spotsOfRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpotsOfRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpotsOfRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpotDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpotDisplayItem[]>;
        }));
    }

    protected processSpotsOfRegistration_Query(response: HttpResponseBase): Observable<SpotDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SpotDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registration_Query(registrationQuery: RegistrationQuery | undefined): Observable<RegistrationDisplayItem> {
        let url_ = this.baseUrl + "/api/RegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationDisplayItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationDisplayItem>;
        }));
    }

    protected processRegistration_Query(response: HttpResponseBase): Observable<RegistrationDisplayItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationDisplayItem;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    swapFirstLastName_Command(swapFirstLastNameCommand: SwapFirstLastNameCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SwapFirstLastNameCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(swapFirstLastNameCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwapFirstLastName_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwapFirstLastName_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSwapFirstLastName_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchRegistration_Query(searchRegistrationQuery: SearchRegistrationQuery | undefined): Observable<RegistrationMatch[]> {
        let url_ = this.baseUrl + "/api/SearchRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationMatch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationMatch[]>;
        }));
    }

    protected processSearchRegistration_Query(response: HttpResponseBase): Observable<RegistrationMatch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationMatch[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    remarksOverview_Query(remarksOverviewQuery: RemarksOverviewQuery | undefined): Observable<RemarksDisplayItem[]> {
        let url_ = this.baseUrl + "/api/RemarksOverviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(remarksOverviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemarksOverview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemarksOverview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RemarksDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RemarksDisplayItem[]>;
        }));
    }

    protected processRemarksOverview_Query(response: HttpResponseBase): Observable<RemarksDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RemarksDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setRemarksProcessedState_Command(setRemarksProcessedStateCommand: SetRemarksProcessedStateCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetRemarksProcessedStateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setRemarksProcessedStateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRemarksProcessedState_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRemarksProcessedState_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetRemarksProcessedState_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processRawRegistration_Command(processRawRegistrationCommand: ProcessRawRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessRawRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processRawRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessRawRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessRawRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessRawRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    startProcessAllPendingRawRegistrations_Command(startProcessAllPendingRawRegistrationsCommand: StartProcessAllPendingRawRegistrationsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/StartProcessAllPendingRawRegistrationsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(startProcessAllPendingRawRegistrationsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartProcessAllPendingRawRegistrations_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartProcessAllPendingRawRegistrations_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processStartProcessAllPendingRawRegistrations_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unprocessedRawRegistrationCount_Query(unprocessedRawRegistrationCountQuery: UnprocessedRawRegistrationCountQuery | undefined): Observable<UnprocessedRawRegistrationsInfo> {
        let url_ = this.baseUrl + "/api/UnprocessedRawRegistrationCountQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unprocessedRawRegistrationCountQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnprocessedRawRegistrationCount_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnprocessedRawRegistrationCount_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnprocessedRawRegistrationsInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnprocessedRawRegistrationsInfo>;
        }));
    }

    protected processUnprocessedRawRegistrationCount_Query(response: HttpResponseBase): Observable<UnprocessedRawRegistrationsInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessedRawRegistrationsInfo;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setReduction_Command(setReductionCommand: SetReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allExternalRegistrationIdentifiers_Query(allExternalRegistrationIdentifiersQuery: AllExternalRegistrationIdentifiersQuery | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/AllExternalRegistrationIdentifiersQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(allExternalRegistrationIdentifiersQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllExternalRegistrationIdentifiers_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllExternalRegistrationIdentifiers_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processAllExternalRegistrationIdentifiers_Query(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    pricePackagePartSelectionType_Query(pricePackagePartSelectionTypeQuery: PricePackagePartSelectionTypeQuery | undefined): Observable<PricePackagePartSelectionTypeOption[]> {
        let url_ = this.baseUrl + "/api/PricePackagePartSelectionTypeQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pricePackagePartSelectionTypeQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPricePackagePartSelectionType_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPricePackagePartSelectionType_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PricePackagePartSelectionTypeOption[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PricePackagePartSelectionTypeOption[]>;
        }));
    }

    protected processPricePackagePartSelectionType_Query(response: HttpResponseBase): Observable<PricePackagePartSelectionTypeOption[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PricePackagePartSelectionTypeOption[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    recalculatePriceAndWaitingList_Command(recalculatePriceAndWaitingListCommand: RecalculatePriceAndWaitingListCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RecalculatePriceAndWaitingListCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recalculatePriceAndWaitingListCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalculatePriceAndWaitingList_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalculatePriceAndWaitingList_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRecalculatePriceAndWaitingList_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkin_Query(checkinQuery: CheckinQuery | undefined): Observable<CheckinView> {
        let url_ = this.baseUrl + "/api/CheckinQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkinQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckin_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckin_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckinView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckinView>;
        }));
    }

    protected processCheckin_Query(response: HttpResponseBase): Observable<CheckinView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckinView;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    partyOverview_Query(partyOverviewQuery: PartyOverviewQuery | undefined): Observable<PartyItem[]> {
        let url_ = this.baseUrl + "/api/PartyOverviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(partyOverviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartyOverview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartyOverview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartyItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartyItem[]>;
        }));
    }

    protected processPartyOverview_Query(response: HttpResponseBase): Observable<PartyItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartyItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeUnmatchedPartnerRegistrationToSingleRegistration_Command(changeUnmatchedPartnerRegistrationToSingleRegistrationCommand: ChangeUnmatchedPartnerRegistrationToSingleRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ChangeUnmatchedPartnerRegistrationToSingleRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeUnmatchedPartnerRegistrationToSingleRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUnmatchedPartnerRegistrationToSingleRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUnmatchedPartnerRegistrationToSingleRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processChangeUnmatchedPartnerRegistrationToSingleRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    matchPartnerRegistrations_Command(matchPartnerRegistrationsCommand: MatchPartnerRegistrationsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/MatchPartnerRegistrationsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(matchPartnerRegistrationsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMatchPartnerRegistrations_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMatchPartnerRegistrations_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processMatchPartnerRegistrations_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    potentialPartners_Query(potentialPartnersQuery: PotentialPartnersQuery | undefined): Observable<PotentialPartners> {
        let url_ = this.baseUrl + "/api/PotentialPartnersQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(potentialPartnersQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPotentialPartners_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPotentialPartners_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PotentialPartners>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PotentialPartners>;
        }));
    }

    protected processPotentialPartners_Query(response: HttpResponseBase): Observable<PotentialPartners> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PotentialPartners;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrationsWithUnmatchedPartner_Query(registrationsWithUnmatchedPartnerQuery: RegistrationsWithUnmatchedPartnerQuery | undefined): Observable<PotentialPartnerMatch[]> {
        let url_ = this.baseUrl + "/api/RegistrationsWithUnmatchedPartnerQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationsWithUnmatchedPartnerQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationsWithUnmatchedPartner_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationsWithUnmatchedPartner_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PotentialPartnerMatch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PotentialPartnerMatch[]>;
        }));
    }

    protected processRegistrationsWithUnmatchedPartner_Query(response: HttpResponseBase): Observable<PotentialPartnerMatch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PotentialPartnerMatch[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unbindPartnerRegistration_Command(unbindPartnerRegistrationCommand: UnbindPartnerRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UnbindPartnerRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unbindPartnerRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnbindPartnerRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnbindPartnerRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUnbindPartnerRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    internalNotes_Query(internalNotesQuery: InternalNotesQuery | undefined): Observable<NotesDisplayItem[]> {
        let url_ = this.baseUrl + "/api/InternalNotesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(internalNotesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInternalNotes_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInternalNotes_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotesDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotesDisplayItem[]>;
        }));
    }

    protected processInternalNotes_Query(response: HttpResponseBase): Observable<NotesDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotesDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateInternalNotes_Command(updateInternalNotesCommand: UpdateInternalNotesCommand | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/UpdateInternalNotesCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateInternalNotesCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateInternalNotes_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateInternalNotes_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUpdateInternalNotes_Command(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addIndividualReduction_Command(addIndividualReductionCommand: AddIndividualReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AddIndividualReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addIndividualReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddIndividualReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddIndividualReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAddIndividualReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeIndividualReduction_Command(removeIndividualReductionCommand: RemoveIndividualReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RemoveIndividualReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeIndividualReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveIndividualReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveIndividualReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRemoveIndividualReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkRegistrationAfterPayment_Command(checkRegistrationAfterPaymentCommand: CheckRegistrationAfterPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckRegistrationAfterPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkRegistrationAfterPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRegistrationAfterPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRegistrationAfterPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckRegistrationAfterPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancelRegistration_Command(cancelRegistrationCommand: CancelRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CancelRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cancelRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCancelRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrationFormTypes_Query(registrationFormTypesQuery: RegistrationFormTypesQuery | undefined): Observable<RegistrationFormType[]> {
        let url_ = this.baseUrl + "/api/RegistrationFormTypesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationFormTypesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationFormTypes_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationFormTypes_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFormType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFormType[]>;
        }));
    }

    protected processRegistrationFormTypes_Query(response: HttpResponseBase): Observable<RegistrationFormType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationFormType[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    availableQuestionMappings_Query(availableQuestionMappingsQuery: AvailableQuestionMappingsQuery | undefined): Observable<AvailableQuestionMapping[]> {
        let url_ = this.baseUrl + "/api/AvailableQuestionMappingsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(availableQuestionMappingsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableQuestionMappings_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableQuestionMappings_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableQuestionMapping[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableQuestionMapping[]>;
        }));
    }

    protected processAvailableQuestionMappings_Query(response: HttpResponseBase): Observable<AvailableQuestionMapping[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableQuestionMapping[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    availableQuestionOptionMappings_Query(availableQuestionOptionMappingsQuery: AvailableQuestionOptionMappingsQuery | undefined): Observable<AvailableQuestionOptionMapping[]> {
        let url_ = this.baseUrl + "/api/AvailableQuestionOptionMappingsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(availableQuestionOptionMappingsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableQuestionOptionMappings_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableQuestionOptionMappings_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableQuestionOptionMapping[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableQuestionOptionMapping[]>;
        }));
    }

    protected processAvailableQuestionOptionMappings_Query(response: HttpResponseBase): Observable<AvailableQuestionOptionMapping[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableQuestionOptionMapping[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveRegistrationFormMappings_Command(saveRegistrationFormMappingsCommand: SaveRegistrationFormMappingsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveRegistrationFormMappingsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveRegistrationFormMappingsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRegistrationFormMappings_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRegistrationFormMappings_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveRegistrationFormMappings_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRegistrationForm_Command(deleteRegistrationFormCommand: DeleteRegistrationFormCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteRegistrationFormCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteRegistrationFormCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegistrationForm_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegistrationForm_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteRegistrationForm_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importRegistrationForm_Command(importRegistrationFormCommand: ImportRegistrationFormCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ImportRegistrationFormCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importRegistrationFormCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportRegistrationForm_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportRegistrationForm_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processImportRegistrationForm_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrationForms_Query(registrationFormsQuery: RegistrationFormsQuery | undefined): Observable<RegistrationFormItem[]> {
        let url_ = this.baseUrl + "/api/RegistrationFormsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationFormsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationForms_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationForms_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFormItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFormItem[]>;
        }));
    }

    protected processRegistrationForms_Query(response: HttpResponseBase): Observable<RegistrationFormItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationFormItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    formPaths_Query(formPathsQuery: FormPathsQuery | undefined): Observable<RegistrationFormGroup[]> {
        let url_ = this.baseUrl + "/api/FormPathsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(formPathsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormPaths_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormPaths_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFormGroup[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFormGroup[]>;
        }));
    }

    protected processFormPaths_Query(response: HttpResponseBase): Observable<RegistrationFormGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationFormGroup[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRegistrable_Command(deleteRegistrableCommand: DeleteRegistrableCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteRegistrableCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteRegistrableCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegistrable_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegistrable_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteRegistrable_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrablesOverview_Query(registrablesOverviewQuery: RegistrablesOverviewQuery | undefined): Observable<RegistrablesOverview> {
        let url_ = this.baseUrl + "/api/RegistrablesOverviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrablesOverviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrablesOverview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrablesOverview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrablesOverview>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrablesOverview>;
        }));
    }

    protected processRegistrablesOverview_Query(response: HttpResponseBase): Observable<RegistrablesOverview> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrablesOverview;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrables_Query(registrablesQuery: RegistrablesQuery | undefined): Observable<RegistrableDisplayItem[]> {
        let url_ = this.baseUrl + "/api/RegistrablesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrablesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrables_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrables_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrableDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrableDisplayItem[]>;
        }));
    }

    protected processRegistrables_Query(response: HttpResponseBase): Observable<RegistrableDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrableDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrableTypes_Query(registrableTypesQuery: RegistrableTypesQuery | undefined): Observable<RegistrableTypeOption[]> {
        let url_ = this.baseUrl + "/api/RegistrableTypesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrableTypesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrableTypes_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrableTypes_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrableTypeOption[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrableTypeOption[]>;
        }));
    }

    protected processRegistrableTypes_Query(response: HttpResponseBase): Observable<RegistrableTypeOption[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrableTypeOption[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveRegistrable_Command(saveRegistrableCommand: SaveRegistrableCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveRegistrableCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveRegistrableCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRegistrable_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRegistrable_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveRegistrable_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setFallbackToPartyPass_Command(setFallbackToPartyPassCommand: SetFallbackToPartyPassCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetFallbackToPartyPassCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setFallbackToPartyPassCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFallbackToPartyPass_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFallbackToPartyPass_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetFallbackToPartyPass_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activateAutomaticPromotion_Command(activateAutomaticPromotionCommand: ActivateAutomaticPromotionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ActivateAutomaticPromotionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activateAutomaticPromotionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateAutomaticPromotion_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateAutomaticPromotion_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processActivateAutomaticPromotion_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deactivateAutomaticPromotion_Command(deactivateAutomaticPromotionCommand: DeactivateAutomaticPromotionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeactivateAutomaticPromotionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivateAutomaticPromotionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateAutomaticPromotion_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateAutomaticPromotion_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeactivateAutomaticPromotion_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    triggerMoveUpFromWaitingList_Command(triggerMoveUpFromWaitingListCommand: TriggerMoveUpFromWaitingListCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/TriggerMoveUpFromWaitingListCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(triggerMoveUpFromWaitingListCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTriggerMoveUpFromWaitingList_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTriggerMoveUpFromWaitingList_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processTriggerMoveUpFromWaitingList_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrableTags_Query(registrableTagsQuery: RegistrableTagsQuery | undefined): Observable<RegistrableTagDisplayItem[]> {
        let url_ = this.baseUrl + "/api/RegistrableTagsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrableTagsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrableTags_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrableTags_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrableTagDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrableTagDisplayItem[]>;
        }));
    }

    protected processRegistrableTags_Query(response: HttpResponseBase): Observable<RegistrableTagDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrableTagDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteReduction_Command(deleteReductionCommand: DeleteReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveReduction_Command(saveReductionCommand: SaveReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    pricing_Query(pricingQuery: PricingQuery | undefined): Observable<PricePackageDto[]> {
        let url_ = this.baseUrl + "/api/PricingQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pricingQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPricing_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPricing_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PricePackageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PricePackageDto[]>;
        }));
    }

    protected processPricing_Query(response: HttpResponseBase): Observable<PricePackageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PricePackageDto[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    savePricing_Command(savePricingCommand: SavePricingCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SavePricingCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(savePricingCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePricing_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePricing_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSavePricing_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setRegistrablesPrices_Command(setRegistrablesPricesCommand: SetRegistrablesPricesCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetRegistrablesPricesCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setRegistrablesPricesCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRegistrablesPrices_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRegistrablesPrices_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetRegistrablesPrices_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    participantsOfRegistrable_Query(participantsOfRegistrableQuery: ParticipantsOfRegistrableQuery | undefined): Observable<RegistrableDisplayInfo> {
        let url_ = this.baseUrl + "/api/ParticipantsOfRegistrableQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(participantsOfRegistrableQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipantsOfRegistrable_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipantsOfRegistrable_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrableDisplayInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrableDisplayInfo>;
        }));
    }

    protected processParticipantsOfRegistrable_Query(response: HttpResponseBase): Observable<RegistrableDisplayInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrableDisplayInfo;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processReceivedSms_Command(processReceivedSmsCommand: ProcessReceivedSmsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessReceivedSmsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processReceivedSmsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessReceivedSms_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessReceivedSms_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessReceivedSms_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendSms_Command(sendSmsCommand: SendSmsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendSmsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendSmsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSms_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSms_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendSms_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    smsConversation_Query(smsConversationQuery: SmsConversationQuery | undefined): Observable<SmsDisplayItem[]> {
        let url_ = this.baseUrl + "/api/SmsConversationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(smsConversationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSmsConversation_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSmsConversation_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SmsDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SmsDisplayItem[]>;
        }));
    }

    protected processSmsConversation_Query(response: HttpResponseBase): Observable<SmsDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SmsDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    ignorePayment_Command(ignorePaymentCommand: IgnorePaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/IgnorePaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ignorePaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIgnorePayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIgnorePayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processIgnorePayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentOverview_Query(paymentOverviewQuery: PaymentOverviewQuery | undefined): Observable<PaymentOverview> {
        let url_ = this.baseUrl + "/api/PaymentOverviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentOverviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentOverview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentOverview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOverview>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOverview>;
        }));
    }

    protected processPaymentOverview_Query(response: HttpResponseBase): Observable<PaymentOverview> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentOverview;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unassignedIncomingPayments_Query(unassignedIncomingPaymentsQuery: UnassignedIncomingPaymentsQuery | undefined): Observable<PaymentDisplayItem[]> {
        let url_ = this.baseUrl + "/api/UnassignedIncomingPaymentsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unassignedIncomingPaymentsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnassignedIncomingPayments_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnassignedIncomingPayments_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDisplayItem[]>;
        }));
    }

    protected processUnassignedIncomingPayments_Query(response: HttpResponseBase): Observable<PaymentDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unassignedPayouts_Query(unassignedPayoutsQuery: UnassignedPayoutsQuery | undefined): Observable<PaymentDisplayItem[]> {
        let url_ = this.baseUrl + "/api/UnassignedPayoutsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unassignedPayoutsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnassignedPayouts_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnassignedPayouts_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDisplayItem[]>;
        }));
    }

    protected processUnassignedPayouts_Query(response: HttpResponseBase): Observable<PaymentDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfIncomingPaymentIsSettled_Command(checkIfIncomingPaymentIsSettledCommand: CheckIfIncomingPaymentIsSettledCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckIfIncomingPaymentIsSettledCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkIfIncomingPaymentIsSettledCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfIncomingPaymentIsSettled_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfIncomingPaymentIsSettled_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckIfIncomingPaymentIsSettled_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfOutgoingPaymentIsSettled_Command(checkIfOutgoingPaymentIsSettledCommand: CheckIfOutgoingPaymentIsSettledCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckIfOutgoingPaymentIsSettledCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkIfOutgoingPaymentIsSettledCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfOutgoingPaymentIsSettled_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfOutgoingPaymentIsSettled_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckIfOutgoingPaymentIsSettled_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentsByDay_Query(paymentsByDayQuery: PaymentsByDayQuery | undefined): Observable<BookingsOfDay[]> {
        let url_ = this.baseUrl + "/api/PaymentsByDayQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentsByDayQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentsByDay_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentsByDay_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingsOfDay[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingsOfDay[]>;
        }));
    }

    protected processPaymentsByDay_Query(response: HttpResponseBase): Observable<BookingsOfDay[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookingsOfDay[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bookingsByState_Query(bookingsByStateQuery: BookingsByStateQuery | undefined): Observable<PaymentDisplayItem3[]> {
        let url_ = this.baseUrl + "/api/BookingsByStateQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bookingsByStateQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookingsByState_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookingsByState_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDisplayItem3[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDisplayItem3[]>;
        }));
    }

    protected processBookingsByState_Query(response: HttpResponseBase): Observable<PaymentDisplayItem3[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentDisplayItem3[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignOutgoingPayment_Command(assignOutgoingPaymentCommand: AssignOutgoingPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AssignOutgoingPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignOutgoingPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignOutgoingPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignOutgoingPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAssignOutgoingPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfPayoutIsConfirmed_Command(checkIfPayoutIsConfirmedCommand: CheckIfPayoutIsConfirmedCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckIfPayoutIsConfirmedCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkIfPayoutIsConfirmedCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfPayoutIsConfirmed_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfPayoutIsConfirmed_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckIfPayoutIsConfirmed_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    payout_Query(payoutQuery: PayoutQuery | undefined): Observable<PayoutDisplayItem[]> {
        let url_ = this.baseUrl + "/api/PayoutQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payoutQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayout_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayout_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayoutDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayoutDisplayItem[]>;
        }));
    }

    protected processPayout_Query(response: HttpResponseBase): Observable<PayoutDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PayoutDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possiblePayoutAssignment_Query(possiblePayoutAssignmentQuery: PossiblePayoutAssignmentQuery | undefined): Observable<PossiblePayoutAssignment[]> {
        let url_ = this.baseUrl + "/api/PossiblePayoutAssignmentQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possiblePayoutAssignmentQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossiblePayoutAssignment_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossiblePayoutAssignment_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PossiblePayoutAssignment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PossiblePayoutAssignment[]>;
        }));
    }

    protected processPossiblePayoutAssignment_Query(response: HttpResponseBase): Observable<PossiblePayoutAssignment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PossiblePayoutAssignment[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refunds_Query(refundsQuery: RefundsQuery | undefined): Observable<RefundDisplayItem[]> {
        let url_ = this.baseUrl + "/api/RefundsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refundsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefunds_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefunds_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefundDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefundDisplayItem[]>;
        }));
    }

    protected processRefunds_Query(response: HttpResponseBase): Observable<RefundDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RefundDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    willPayAtCheckin_Command(willPayAtCheckinCommand: WillPayAtCheckinCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/WillPayAtCheckinCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(willPayAtCheckinCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWillPayAtCheckin_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWillPayAtCheckin_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processWillPayAtCheckin_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    savePaymentFile_Command(savePaymentFileCommand: SavePaymentFileCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SavePaymentFileCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(savePaymentFileCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePaymentFile_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePaymentFile_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSavePaymentFile_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentSlipImage_Query(paymentSlipImageQuery: PaymentSlipImageQuery | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PaymentSlipImageQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentSlipImageQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentSlipImage_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentSlipImage_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPaymentSlipImage_Query(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    tryAssignPaymentSlip_Command(tryAssignPaymentSlipCommand: TryAssignPaymentSlipCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/TryAssignPaymentSlipCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tryAssignPaymentSlipCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTryAssignPaymentSlip_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTryAssignPaymentSlip_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processTryAssignPaymentSlip_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    fetchBankStatementsFile_Command(fetchBankStatementsFileCommand: FetchBankStatementsFileCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/FetchBankStatementsFileCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fetchBankStatementsFileCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchBankStatementsFile_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchBankStatementsFile_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processFetchBankStatementsFile_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processFetchedBankStatementsFile_Command(processFetchedBankStatementsFileCommand: ProcessFetchedBankStatementsFileCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessFetchedBankStatementsFileCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processFetchedBankStatementsFileCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessFetchedBankStatementsFile_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessFetchedBankStatementsFile_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessFetchedBankStatementsFile_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    duePayments_Query(duePaymentsQuery: DuePaymentsQuery | undefined): Observable<DuePaymentItem[]> {
        let url_ = this.baseUrl + "/api/DuePaymentsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(duePaymentsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDuePayments_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDuePayments_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DuePaymentItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DuePaymentItem[]>;
        }));
    }

    protected processDuePayments_Query(response: HttpResponseBase): Observable<DuePaymentItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DuePaymentItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendReminderMail_Command(sendReminderMailCommand: SendReminderMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendReminderMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendReminderMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReminderMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReminderMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendReminderMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    differences_Query(differencesQuery: DifferencesQuery | undefined): Observable<DifferencesDisplayItem[]> {
        let url_ = this.baseUrl + "/api/DifferencesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(differencesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDifferences_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDifferences_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DifferencesDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DifferencesDisplayItem[]>;
        }));
    }

    protected processDifferences_Query(response: HttpResponseBase): Observable<DifferencesDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DifferencesDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refundDifference_Command(refundDifferenceCommand: RefundDifferenceCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RefundDifferenceCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refundDifferenceCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundDifference_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundDifference_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRefundDifference_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendPaymentDueMail_Command(sendPaymentDueMailCommand: SendPaymentDueMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendPaymentDueMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendPaymentDueMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPaymentDueMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPaymentDueMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendPaymentDueMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignedPaymentsOfRegistration_Query(assignedPaymentsOfRegistrationQuery: AssignedPaymentsOfRegistrationQuery | undefined): Observable<AssignedPaymentDisplayItem[]> {
        let url_ = this.baseUrl + "/api/AssignedPaymentsOfRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignedPaymentsOfRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignedPaymentsOfRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignedPaymentsOfRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssignedPaymentDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssignedPaymentDisplayItem[]>;
        }));
    }

    protected processAssignedPaymentsOfRegistration_Query(response: HttpResponseBase): Observable<AssignedPaymentDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssignedPaymentDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignIncomingPayment_Command(assignIncomingPaymentCommand: AssignIncomingPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AssignIncomingPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignIncomingPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignIncomingPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignIncomingPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAssignIncomingPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignRepayment_Command(assignRepaymentCommand: AssignRepaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AssignRepaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignRepaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignRepayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignRepayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAssignRepayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentAssignments_Query(paymentAssignmentsQuery: PaymentAssignmentsQuery | undefined): Observable<PaymentAssignments> {
        let url_ = this.baseUrl + "/api/PaymentAssignmentsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentAssignmentsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentAssignments_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentAssignments_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAssignments>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAssignments>;
        }));
    }

    protected processPaymentAssignments_Query(response: HttpResponseBase): Observable<PaymentAssignments> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentAssignments;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possibleRepaymentAssignment_Query(possibleRepaymentAssignmentQuery: PossibleRepaymentAssignmentQuery | undefined): Observable<PossibleRepaymentAssignment[]> {
        let url_ = this.baseUrl + "/api/PossibleRepaymentAssignmentQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possibleRepaymentAssignmentQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossibleRepaymentAssignment_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossibleRepaymentAssignment_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PossibleRepaymentAssignment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PossibleRepaymentAssignment[]>;
        }));
    }

    protected processPossibleRepaymentAssignment_Query(response: HttpResponseBase): Observable<PossibleRepaymentAssignment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PossibleRepaymentAssignment[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unassignPayment_Command(unassignPaymentCommand: UnassignPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UnassignPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unassignPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnassignPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnassignPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUnassignPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMail_Command(deleteMailCommand: DeleteMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    mailsOfRegistration_Query(mailsOfRegistrationQuery: MailsOfRegistrationQuery | undefined): Observable<MailDisplayItem2[]> {
        let url_ = this.baseUrl + "/api/MailsOfRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mailsOfRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMailsOfRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMailsOfRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailDisplayItem2[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailDisplayItem2[]>;
        }));
    }

    protected processMailsOfRegistration_Query(response: HttpResponseBase): Observable<MailDisplayItem2[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MailDisplayItem2[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    mailView_Query(mailViewQuery: MailViewQuery | undefined): Observable<MailView> {
        let url_ = this.baseUrl + "/api/MailViewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mailViewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMailView_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMailView_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailView>;
        }));
    }

    protected processMailView_Query(response: HttpResponseBase): Observable<MailView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MailView;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    pendingMails_Query(pendingMailsQuery: PendingMailsQuery | undefined): Observable<PendingMailListItem[]> {
        let url_ = this.baseUrl + "/api/PendingMailsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pendingMailsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPendingMails_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPendingMails_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PendingMailListItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PendingMailListItem[]>;
        }));
    }

    protected processPendingMails_Query(response: HttpResponseBase): Observable<PendingMailListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PendingMailListItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    releaseAllPendingMails_Command(releaseAllPendingMailsCommand: ReleaseAllPendingMailsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ReleaseAllPendingMailsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(releaseAllPendingMailsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseAllPendingMails_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseAllPendingMails_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processReleaseAllPendingMails_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    releaseMail_Command(releaseMailCommand: ReleaseMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ReleaseMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(releaseMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processReleaseMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resendSentMailsWithoutState_Command(resendSentMailsWithoutStateCommand: ResendSentMailsWithoutStateCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ResendSentMailsWithoutStateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendSentMailsWithoutStateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendSentMailsWithoutState_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendSentMailsWithoutState_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processResendSentMailsWithoutState_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    autoMailPreview_Query(autoMailPreviewQuery: AutoMailPreviewQuery | undefined): Observable<AutoMailPreview> {
        let url_ = this.baseUrl + "/api/AutoMailPreviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(autoMailPreviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoMailPreview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoMailPreview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoMailPreview>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoMailPreview>;
        }));
    }

    protected processAutoMailPreview_Query(response: HttpResponseBase): Observable<AutoMailPreview> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AutoMailPreview;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    autoMailTemplate_Query(autoMailTemplateQuery: AutoMailTemplateQuery | undefined): Observable<AutoMailTemplateDisplayItem> {
        let url_ = this.baseUrl + "/api/AutoMailTemplateQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(autoMailTemplateQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoMailTemplate_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoMailTemplate_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoMailTemplateDisplayItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoMailTemplateDisplayItem>;
        }));
    }

    protected processAutoMailTemplate_Query(response: HttpResponseBase): Observable<AutoMailTemplateDisplayItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AutoMailTemplateDisplayItem;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    autoMailTemplates_Query(autoMailTemplatesQuery: AutoMailTemplatesQuery | undefined): Observable<AutoMailTemplates> {
        let url_ = this.baseUrl + "/api/AutoMailTemplatesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(autoMailTemplatesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoMailTemplates_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoMailTemplates_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AutoMailTemplates>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AutoMailTemplates>;
        }));
    }

    protected processAutoMailTemplates_Query(response: HttpResponseBase): Observable<AutoMailTemplates> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AutoMailTemplates;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createAutoMailTemplate_Command(createAutoMailTemplateCommand: CreateAutoMailTemplateCommand | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/CreateAutoMailTemplateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createAutoMailTemplateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAutoMailTemplate_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAutoMailTemplate_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateAutoMailTemplate_Command(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setReleaseMail_Command(setReleaseMailCommand: SetReleaseMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetReleaseMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setReleaseMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetReleaseMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetReleaseMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetReleaseMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAutoMailConfiguration_Command(updateAutoMailConfigurationCommand: UpdateAutoMailConfigurationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UpdateAutoMailConfigurationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAutoMailConfigurationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAutoMailConfiguration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAutoMailConfiguration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUpdateAutoMailConfiguration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAutoMailTemplate_Command(updateAutoMailTemplateCommand: UpdateAutoMailTemplateCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UpdateAutoMailTemplateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateAutoMailTemplateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAutoMailTemplate_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAutoMailTemplate_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUpdateAutoMailTemplate_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendMail_Command(sendMailCommand: SendMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possibleMailTypes_Query(possibleMailTypesQuery: PossibleMailTypesQuery | undefined): Observable<MailTypeItem[]> {
        let url_ = this.baseUrl + "/api/PossibleMailTypesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possibleMailTypesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossibleMailTypes_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossibleMailTypes_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailTypeItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailTypeItem[]>;
        }));
    }

    protected processPossibleMailTypes_Query(response: HttpResponseBase): Observable<MailTypeItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MailTypeItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    fixInvalidAddress_Command(fixInvalidAddressCommand: FixInvalidAddressCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/FixInvalidAddressCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fixInvalidAddressCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFixInvalidAddress_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFixInvalidAddress_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processFixInvalidAddress_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    invalidAddresses_Query(invalidAddressesQuery: InvalidAddressesQuery | undefined): Observable<InvalidAddress[]> {
        let url_ = this.baseUrl + "/api/InvalidAddressesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invalidAddressesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvalidAddresses_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvalidAddresses_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvalidAddress[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvalidAddress[]>;
        }));
    }

    protected processInvalidAddresses_Query(response: HttpResponseBase): Observable<InvalidAddress[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InvalidAddress[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    notReceivedMails_Query(notReceivedMailsQuery: NotReceivedMailsQuery | undefined): Observable<ProblematicEmail[]> {
        let url_ = this.baseUrl + "/api/NotReceivedMailsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notReceivedMailsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotReceivedMails_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotReceivedMails_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProblematicEmail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProblematicEmail[]>;
        }));
    }

    protected processNotReceivedMails_Query(response: HttpResponseBase): Observable<ProblematicEmail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblematicEmail[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importMailsFromImap_Command(importMailsFromImapCommand: ImportMailsFromImapCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ImportMailsFromImapCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importMailsFromImapCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMailsFromImap_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMailsFromImap_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processImportMailsFromImap_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importMailsFromImapForAllActiveEvents_Command(importMailsFromImapForAllActiveEventsCommand: ImportMailsFromImapForAllActiveEventsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ImportMailsFromImapForAllActiveEventsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importMailsFromImapForAllActiveEventsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMailsFromImapForAllActiveEvents_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMailsFromImapForAllActiveEvents_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processImportMailsFromImapForAllActiveEvents_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    tryAssignImportedMail_Command(tryAssignImportedMailCommand: TryAssignImportedMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/TryAssignImportedMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tryAssignImportedMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTryAssignImportedMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTryAssignImportedMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processTryAssignImportedMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processMailEvents_Command(processMailEventsCommand: ProcessMailEventsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessMailEventsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processMailEventsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessMailEvents_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessMailEvents_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessMailEvents_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    autoMailPlaceholder_Query(autoMailPlaceholderQuery: AutoMailPlaceholderQuery | undefined): Observable<PlaceholderDescription[]> {
        let url_ = this.baseUrl + "/api/AutoMailPlaceholderQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(autoMailPlaceholderQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAutoMailPlaceholder_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAutoMailPlaceholder_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlaceholderDescription[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlaceholderDescription[]>;
        }));
    }

    protected processAutoMailPlaceholder_Query(response: HttpResponseBase): Observable<PlaceholderDescription[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PlaceholderDescription[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    composeAndSendAutoMail_Command(composeAndSendAutoMailCommand: ComposeAndSendAutoMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ComposeAndSendAutoMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(composeAndSendAutoMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComposeAndSendAutoMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComposeAndSendAutoMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processComposeAndSendAutoMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    composeAndSendBulkMail_Command(composeAndSendBulkMailCommand: ComposeAndSendBulkMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ComposeAndSendBulkMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(composeAndSendBulkMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComposeAndSendBulkMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComposeAndSendBulkMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processComposeAndSendBulkMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bulkMailTemplates_Query(bulkMailTemplatesQuery: BulkMailTemplatesQuery | undefined): Observable<BulkMailTemplates> {
        let url_ = this.baseUrl + "/api/BulkMailTemplatesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bulkMailTemplatesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBulkMailTemplates_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBulkMailTemplates_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BulkMailTemplates>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BulkMailTemplates>;
        }));
    }

    protected processBulkMailTemplates_Query(response: HttpResponseBase): Observable<BulkMailTemplates> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BulkMailTemplates;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createBulkMails_Command(createBulkMailsCommand: CreateBulkMailsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CreateBulkMailsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createBulkMailsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulkMails_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulkMails_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCreateBulkMails_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createBulkMailTemplate_Command(createBulkMailTemplateCommand: CreateBulkMailTemplateCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CreateBulkMailTemplateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createBulkMailTemplateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulkMailTemplate_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulkMailTemplate_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCreateBulkMailTemplate_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteBulkMailTemplate_Command(deleteBulkMailTemplateCommand: DeleteBulkMailTemplateCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteBulkMailTemplateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteBulkMailTemplateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBulkMailTemplate_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBulkMailTemplate_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteBulkMailTemplate_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possibleAudiences_Query(possibleAudiencesQuery: PossibleAudiencesQuery | undefined): Observable<PossibleAudience[]> {
        let url_ = this.baseUrl + "/api/PossibleAudiencesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possibleAudiencesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossibleAudiences_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossibleAudiences_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PossibleAudience[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PossibleAudience[]>;
        }));
    }

    protected processPossibleAudiences_Query(response: HttpResponseBase): Observable<PossibleAudience[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PossibleAudience[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    releaseBulkMails_Command(releaseBulkMailsCommand: ReleaseBulkMailsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ReleaseBulkMailsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(releaseBulkMailsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseBulkMails_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseBulkMails_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processReleaseBulkMails_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    froalaKey_Query(froalaKeyQuery: FroalaKeyQuery | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/FroalaKeyQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(froalaKeyQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFroalaKey_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFroalaKey_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processFroalaKey_Query(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    translation_Query(translationQuery: TranslationQuery | undefined): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/TranslationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(translationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTranslation_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTranslation_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processTranslation_Query(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: string; };
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    domainEventCatalog_Query(domainEventCatalogQuery: DomainEventCatalogQuery | undefined): Observable<DomainEventCatalogItem[]> {
        let url_ = this.baseUrl + "/api/DomainEventCatalogQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(domainEventCatalogQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDomainEventCatalog_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDomainEventCatalog_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DomainEventCatalogItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DomainEventCatalogItem[]>;
        }));
    }

    protected processDomainEventCatalog_Query(response: HttpResponseBase): Observable<DomainEventCatalogItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DomainEventCatalogItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    domainEvents_Query(domainEventsQuery: DomainEventsQuery | undefined): Observable<DomainEventDisplayItem[]> {
        let url_ = this.baseUrl + "/api/DomainEventsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(domainEventsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDomainEvents_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDomainEvents_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DomainEventDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DomainEventDisplayItem[]>;
        }));
    }

    protected processDomainEvents_Query(response: HttpResponseBase): Observable<DomainEventDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DomainEventDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveDomainEvent_Command(saveDomainEventCommand: SaveDomainEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveDomainEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveDomainEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDomainEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDomainEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveDomainEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    startUpdateReadModelsOfEvent_Command(startUpdateReadModelsOfEventCommand: StartUpdateReadModelsOfEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/StartUpdateReadModelsOfEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(startUpdateReadModelsOfEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartUpdateReadModelsOfEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartUpdateReadModelsOfEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processStartUpdateReadModelsOfEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateReadModel_Command(updateReadModelCommand: UpdateReadModelCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UpdateReadModelCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateReadModelCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReadModel_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReadModel_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUpdateReadModel_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    hostingOffers_Query(hostingOffersQuery: HostingOffersQuery | undefined): Observable<HostingOffers> {
        let url_ = this.baseUrl + "/api/HostingOffersQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(hostingOffersQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHostingOffers_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHostingOffers_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostingOffers>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostingOffers>;
        }));
    }

    protected processHostingOffers_Query(response: HttpResponseBase): Observable<HostingOffers> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HostingOffers;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    hostingRequests_Query(hostingRequestsQuery: HostingRequestsQuery | undefined): Observable<HostingRequests> {
        let url_ = this.baseUrl + "/api/HostingRequestsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(hostingRequestsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHostingRequests_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHostingRequests_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostingRequests>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostingRequests>;
        }));
    }

    protected processHostingRequests_Query(response: HttpResponseBase): Observable<HostingRequests> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HostingRequests;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createEvent_Command(createEventCommand: CreateEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CreateEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCreateEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventByAcronym_Query(eventByAcronymQuery: EventByAcronymQuery | undefined): Observable<EventDetails> {
        let url_ = this.baseUrl + "/api/EventByAcronymQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventByAcronymQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventByAcronym_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventByAcronym_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDetails>;
        }));
    }

    protected processEventByAcronym_Query(response: HttpResponseBase): Observable<EventDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EventDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    event_Query(eventQuery: EventQuery | undefined): Observable<EventDetails> {
        let url_ = this.baseUrl + "/api/EventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDetails>;
        }));
    }

    protected processEvent_Query(response: HttpResponseBase): Observable<EventDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EventDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    openRegistration_Command(openRegistrationCommand: OpenRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/OpenRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(openRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processOpenRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchEvent_Query(searchEventQuery: SearchEventQuery | undefined): Observable<EventSearchResult[]> {
        let url_ = this.baseUrl + "/api/SearchEventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchEventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSearchResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSearchResult[]>;
        }));
    }

    protected processSearchEvent_Query(response: HttpResponseBase): Observable<EventSearchResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EventSearchResult[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventsOfUser_Query(eventsOfUserQuery: EventsOfUserQuery | undefined): Observable<EventsOfUser> {
        let url_ = this.baseUrl + "/api/EventsOfUserQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventsOfUserQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventsOfUser_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventsOfUser_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventsOfUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventsOfUser>;
        }));
    }

    protected processEventsOfUser_Query(response: HttpResponseBase): Observable<EventsOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EventsOfUser;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeUserFromEvent_Command(removeUserFromEventCommand: RemoveUserFromEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RemoveUserFromEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeUserFromEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRemoveUserFromEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setRoleOfUserInEvent_Command(setRoleOfUserInEventCommand: SetRoleOfUserInEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetRoleOfUserInEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setRoleOfUserInEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRoleOfUserInEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRoleOfUserInEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetRoleOfUserInEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    userInEventRoles_Query(userInEventRolesQuery: UserInEventRolesQuery | undefined): Observable<RoleDescription[]> {
        let url_ = this.baseUrl + "/api/UserInEventRolesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInEventRolesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserInEventRoles_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserInEventRoles_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RoleDescription[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RoleDescription[]>;
        }));
    }

    protected processUserInEventRoles_Query(response: HttpResponseBase): Observable<RoleDescription[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoleDescription[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    usersOfEvent_Query(usersOfEventQuery: UsersOfEventQuery | undefined): Observable<UserInEventDisplayItem[]> {
        let url_ = this.baseUrl + "/api/UsersOfEventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usersOfEventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersOfEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersOfEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInEventDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInEventDisplayItem[]>;
        }));
    }

    protected processUsersOfEvent_Query(response: HttpResponseBase): Observable<UserInEventDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserInEventDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accessRequestsOfEvent_Query(accessRequestsOfEventQuery: AccessRequestsOfEventQuery | undefined): Observable<AccessRequestOfEvent[]> {
        let url_ = this.baseUrl + "/api/AccessRequestsOfEventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(accessRequestsOfEventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccessRequestsOfEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccessRequestsOfEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessRequestOfEvent[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessRequestOfEvent[]>;
        }));
    }

    protected processAccessRequestsOfEvent_Query(response: HttpResponseBase): Observable<AccessRequestOfEvent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccessRequestOfEvent[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    requestAccess_Command(requestAccessCommand: RequestAccessCommand | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/RequestAccessCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestAccessCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestAccess_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestAccess_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRequestAccess_Command(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    respondToRequest_Command(respondToRequestCommand: RespondToRequestCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RespondToRequestCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(respondToRequestCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRespondToRequest_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRespondToRequest_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRespondToRequest_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    rightsOfUserInEvent_Query(rightsOfUserInEventQuery: RightsOfUserInEventQuery | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/RightsOfUserInEventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(rightsOfUserInEventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRightsOfUserInEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRightsOfUserInEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processRightsOfUserInEvent_Query(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUserInfo_Command(updateUserInfoCommand: UpdateUserInfoCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UpdateUserInfoCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateUserInfoCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserInfo_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserInfo_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUpdateUserInfo_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** Represents a void type, since Void is not a valid return type in C#. */
export interface Unit {
}

export interface AddSpotCommand {
    asFollower?: boolean;
    eventId?: string;
    registrableId?: string;
    registrationId?: string;
}

export interface RemoveSpotCommand {
    eventId?: string;
    registrableId?: string;
    registrationId?: string;
}

export interface SpotDisplayItem {
    firstPartnerJoined?: Date;
    id?: string;
    isCore?: boolean;
    isWaitingList?: boolean;
    partnerName?: string | null;
    partnerRegistrationId?: string | null;
    registrableName?: string;
    registrableNameSecondary?: string | null;
    registrableId?: string;
    type?: RegistrableType;
    roleText?: string | null;
}

export enum RegistrableType {
    Single = 1,
    Double = 2,
}

export interface SpotsOfRegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface RegistrationDisplayItem {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    isReduced?: boolean;
    isWaitingList?: boolean | null;
    language?: string | null;
    paid?: number;
    partnerId?: string | null;
    partnerOriginal?: string | null;
    partnerName?: string | null;
    phoneNormalized?: string | null;
    phoneFormatted?: string | null;
    price?: number | null;
    receivedAt?: Date;
    remarks?: string | null;
    remarksProcessed?: boolean;
    reminderLevel?: number;
    smsCount?: number;
    soldOutMessage?: string | null;
    status?: RegistrationState;
    willPayAtCheckin?: boolean;
    fallbackToPartyPass?: boolean | null;
    internalNotes?: string | null;
    spots?: SpotDisplayItem[] | null;
    payments?: AssignedPaymentDisplayItem[] | null;
    mails?: MailDisplayItem[] | null;
    reductions?: IndividualReductionDisplayItem[] | null;
}

export enum RegistrationState {
    Received = 1,
    Paid = 2,
    Cancelled = 4,
}

export interface AssignedPaymentDisplayItem {
    amount?: number;
    bookingDate?: Date;
    currency?: string | null;
    paymentAssignmentId?: string;
}

export interface MailDisplayItem {
    mailId?: string;
    subject?: string | null;
    state?: MailState | null;
    created?: Date;
    withhold?: boolean;
    sentAt?: Date | null;
}

export enum MailState {
    Unknown = 0,
    Processed = 1,
    Dropped = 2,
    Delivered = 3,
    Deferred = 4,
    Bounce = 5,
    Open = 6,
    Click = 7,
    SpamReport = 8,
    Unsubscribe = 9,
    GroupUnsubscribe = 10,
    GroupResubscribe = 11,
}

export interface IndividualReductionDisplayItem {
    id?: string;
    type?: IndividualReductionType;
    amount?: number;
    reason?: string | null;
}

export enum IndividualReductionType {
    Reduction = 1,
    OverwritePrice = 2,
}

export interface RegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface SwapFirstLastNameCommand {
    eventId?: string;
    registrationId?: string;
}

export interface RegistrationMatch {
    registrationId?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    isWaitingList?: boolean;
    state?: RegistrationState;
    price?: number;
    amountPaid?: number;
    stateText?: string;
    spots?: SpotShort[];
    receivedAt?: Date;
}

export interface SpotShort {
    name?: string;
    secondary?: string | null;
    isWaitingList?: boolean;
}

export interface SearchRegistrationQuery {
    eventId?: string;
    searchString?: string | null;
    states?: RegistrationState[] | null;
}

export interface RemarksDisplayItem {
    registrationId?: string;
    displayName?: string | null;
    email?: string | null;
    remarks?: string;
    processed?: boolean;
}

export interface RemarksOverviewQuery {
    eventId?: string;
    onlyUnprocessed?: boolean;
}

export interface SetRemarksProcessedStateCommand {
    eventId?: string;
    registrationId?: string;
    newProcessedState?: boolean;
}

export interface ProcessRawRegistrationCommand {
    rawRegistrationId?: string;
}

export interface StartProcessAllPendingRawRegistrationsCommand {
    eventId?: string;
}

export interface UnprocessedRawRegistrationsInfo {
    count?: number;
    firstUnprocessed?: Date | null;
    lastUnprocessed?: Date | null;
    firstProcessed?: Date | null;
    lastProcessed?: Date | null;
    processingErrors?: string[];
}

export interface UnprocessedRawRegistrationCountQuery {
    eventId?: string;
}

export interface SetReductionCommand {
    eventId?: string;
    isReduced?: boolean;
    registrationId?: string;
}

export interface AllExternalRegistrationIdentifiersQuery {
    registrationFormExternalIdentifier?: string;
}

export interface PricePackagePartSelectionTypeOption {
    type?: PricePackagePartSelectionType;
    text?: string;
}

export enum PricePackagePartSelectionType {
    AnyOne = 1,
    AnyTwo = 2,
    AnyThree = 3,
    All = 10,
    Optional = 11,
}

export interface PricePackagePartSelectionTypeQuery {
    eventId?: string;
}

export interface RecalculatePriceAndWaitingListCommand {
    registrationId?: string;
}

export interface CheckinView {
    dynamicHeaders?: string[];
    items?: CheckinViewItem[];
}

export interface CheckinViewItem {
    admittedAt?: Date | null;
    columns?: { [key: string]: string; };
    email?: string;
    firstName?: string;
    lastName?: string;
    registrationId?: string;
    status?: string;
    unsettledAmount?: number;
}

export interface CheckinQuery {
    eventId?: string;
}

export interface PartyItem {
    details?: PartyDetailItem[];
    direct?: number;
    id?: string;
    name?: string;
    partyPassFallbacksOnWaitingList?: number;
    potential?: number;
    potentialOnWaitingList?: number;
    sortyKey?: number | null;
    total?: number;
}

export interface PartyDetailItem {
    id?: string;
    name?: string;
    participants?: number;
    potential?: number;
}

export interface PartyOverviewQuery {
    eventId?: string;
}

export interface ChangeUnmatchedPartnerRegistrationToSingleRegistrationCommand {
    eventId?: string;
    registrationId?: string;
}

export interface MatchPartnerRegistrationsCommand {
    eventId?: string;
    registrationId1?: string;
    registrationId2?: string;
}

export interface PotentialPartners {
    registrationId?: string;
    name?: string | null;
    email?: string | null;
    isOnWaitingList?: boolean;
    state?: RegistrationState;
    declaredPartner?: string | null;
    tracks?: string[] | null;
    matches?: PotentialPartnerMatch[] | null;
}

export interface PotentialPartnerMatch {
    registrationId?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    isOnWaitingList?: boolean;
    declaredPartner?: string | null;
    matchedPartner?: string | null;
    registrationId_Partner?: string | null;
    tracks?: TrackMatch[] | null;
    state?: string;
}

export interface TrackMatch {
    name?: string | null;
    match?: TracksMatch;
}

export enum TracksMatch {
    None = 1,
    Some = 2,
    All = 3,
}

export interface PotentialPartnersQuery {
    eventId?: string;
    registrationId?: string;
    searchString?: string | null;
}

export interface RegistrationsWithUnmatchedPartnerQuery {
    eventId?: string;
}

export interface UnbindPartnerRegistrationCommand {
    eventId?: string;
    registrationId?: string;
}

export interface NotesDisplayItem {
    registrationId?: string;
    displayName?: string | null;
    email?: string | null;
    notes?: string;
}

export interface InternalNotesQuery {
    eventId?: string;
}

export interface UpdateInternalNotesCommand {
    eventId?: string;
    registrationId?: string;
    notes?: string | null;
}

export interface AddIndividualReductionCommand {
    eventId?: string;
    reductionId?: string;
    registrationId?: string;
    type?: IndividualReductionType;
    amount?: number;
    reason?: string | null;
}

export interface RemoveIndividualReductionCommand {
    eventId?: string;
    reductionId?: string;
}

export interface CheckRegistrationAfterPaymentCommand {
    registrationId?: string;
}

export interface CancelRegistrationCommand {
    eventId?: string;
    ignorePayments?: boolean;
    reason?: string | null;
    refundPercentage?: number;
    registrationId?: string;
    received?: Date | null;
}

export interface RegistrationFormType {
    pathType?: FormPathType;
    name?: string;
}

export enum FormPathType {
    Single = 1,
    Partner = 2,
}

export interface RegistrationFormTypesQuery {
}

export interface AvailableQuestionMapping {
    type?: QuestionMappingType;
    text?: string;
}

export enum QuestionMappingType {
    FirstName = 1,
    LastName = 2,
    EMail = 3,
    Phone = 4,
    Town = 5,
    Remarks = 6,
    Iban = 7,
    Partner = 10,
}

export interface AvailableQuestionMappingsQuery {
    eventId?: string;
}

export interface AvailableQuestionOptionMapping {
    type?: MappingType;
    id?: string | null;
    language?: string | null;
    combinedId?: string;
    name?: string | null;
}

export enum MappingType {
    SingleRegistrable = 1,
    PartnerRegistrable = 2,
    PartnerRegistrableLeader = 3,
    PartnerRegistrableFollower = 4,
    Language = 5,
    RoleLeader = 7,
    RoleFollower = 8,
}

export interface AvailableQuestionOptionMappingsQuery {
    eventId?: string;
}

export interface SaveRegistrationFormMappingsCommand {
    eventId?: string;
    formId?: string;
    sections?: FormSection[] | null;
}

export interface FormSection {
    name?: string | null;
    sortKey?: number;
    questions?: QuestionMappingDisplayItem[];
}

export interface QuestionMappingDisplayItem {
    id?: string;
    question?: string | null;
    type?: QuestionType;
    options?: QuestionOptionMappingDisplayItem[] | null;
    sortKey?: number;
    mappable?: boolean;
    mapping?: QuestionMappingType | null;
}

export enum QuestionType {
    Checkbox = 1,
    CheckboxGrid = 2,
    Date = 3,
    Datetime = 4,
    Duration = 5,
    Grid = 6,
    Image = 7,
    List = 8,
    MultipleChoice = 9,
    PageBreak = 10,
    ParagraphText = 11,
    Scale = 12,
    SectionHeader = 13,
    Text = 14,
    Time = 15,
}

export interface QuestionOptionMappingDisplayItem {
    id?: string;
    answer?: string | null;
    mappedRegistrableCombinedIds?: string[] | null;
}

export interface DeleteRegistrationFormCommand {
    eventId?: string;
    registrationFormId?: string;
}

export interface ImportRegistrationFormCommand {
    eventId?: string;
    formExternalIdentifier?: string;
}

export interface RegistrationFormItem {
    registrationFormId?: string | null;
    externalIdentifier?: string;
    state?: EventState;
    title?: string | null;
    sections?: FormSection[];
    lastImport?: Date | null;
    pendingRawFormCreated?: Date | null;
    pendingRawFormId?: string | null;
    deletable?: boolean;
}

export enum EventState {
    Setup = 1,
    RegistrationOpen = 2,
    RegistrationClosed = 3,
    Finished = 4,
}

export interface RegistrationFormsQuery {
    eventId?: string;
}

export interface RegistrationFormGroup {
    id?: string;
    title?: string | null;
    sections?: FormSection[];
}

export interface FormPathsQuery {
    eventId?: string;
}

export interface DeleteRegistrableCommand {
    eventId?: string;
    registrableId?: string;
}

export interface RegistrablesOverview {
    singleRegistrables?: SingleRegistrableDisplayItem[];
    doubleRegistrables?: DoubleRegistrableDisplayItem[];
}

export interface SingleRegistrableDisplayItem {
    id?: string;
    name?: string;
    nameSecondary?: string | null;
    tag?: string | null;
    accepted?: number;
    onWaitingList?: number | null;
    spotsAvailable?: number | null;
    hasWaitingList?: boolean;
    isDeletable?: boolean;
    automaticPromotionFromWaitingList?: boolean;
    class?: SpotState[];
    waitingList?: SpotState[];
}

export enum SpotState {
    Available = 1,
    Reserved = 2,
    Registered = 3,
    Paid = 4,
}

export interface DoubleRegistrableDisplayItem {
    id?: string;
    name?: string;
    nameSecondary?: string | null;
    tag?: string | null;
    couplesOnWaitingList?: number;
    followersAccepted?: number;
    followersOnWaitingList?: number;
    leadersAccepted?: number;
    leadersOnWaitingList?: number;
    maximumAllowedImbalance?: number | null;
    spotsAvailable?: number | null;
    hasWaitingList?: boolean;
    isDeletable?: boolean;
    automaticPromotionFromWaitingList?: boolean;
    class?: DoubleSpotState[];
    waitingList?: DoubleSpotState[];
}

export interface DoubleSpotState {
    leader?: SpotState;
    follower?: SpotState;
    linked?: boolean;
}

export interface RegistrablesOverviewQuery {
    eventId?: string;
}

export interface RegistrableDisplayItem {
    hasWaitingList?: boolean;
    id?: string;
    isDoubleRegistrable?: boolean;
    name?: string;
    nameSecondary?: string | null;
    displayName?: string;
    showInMailListOrder?: number | null;
    sortKey?: number | null;
}

export interface RegistrablesQuery {
    eventId?: string;
}

export interface RegistrableTypeOption {
    type?: RegistrableType;
    text?: string;
}

export interface RegistrableTypesQuery {
    eventId?: string;
}

export interface SaveRegistrableCommand {
    eventId?: string;
    registrableId?: string;
    name?: string | null;
    nameSecondary?: string | null;
    type?: RegistrableType;
    maximumSingleSpots?: number | null;
    maximumDoubleSpots?: number | null;
    maximumAllowedImbalance?: number | null;
    hasWaitingList?: boolean;
    tag?: string | null;
}

export interface SetFallbackToPartyPassCommand {
    eventId?: string;
    registrationId?: string;
}

export interface ActivateAutomaticPromotionCommand {
    eventId?: string;
    tryPromoteImmediately?: boolean;
    registrableId?: string;
}

export interface DeactivateAutomaticPromotionCommand {
    eventId?: string;
    registrableId?: string;
}

export interface TriggerMoveUpFromWaitingListCommand {
    eventId?: string;
    registrableId?: string;
    registrationId?: string | null;
}

export interface RegistrableTagDisplayItem {
    tagId?: string;
    text?: string;
    tag?: string;
    sortKey?: number;
}

export interface RegistrableTagsQuery {
    eventId?: string;
}

export interface DeleteReductionCommand {
    registrableId?: string;
    reductionId?: string;
    eventId?: string;
}

export interface SaveReductionCommand {
    registrableId?: string;
    reductionId?: string;
    amount?: number;
    registrableId1_ReductionActivatedIfCombinedWith?: string | null;
    registrableId2_ReductionActivatedIfCombinedWith?: string | null;
    eventId?: string;
}

export interface PricePackageDto {
    id?: string;
    name?: string | null;
    price?: number;
    allowAsFallback?: boolean;
    parts?: PricePackagePartDto[] | null;
}

export interface PricePackagePartDto {
    id?: string;
    selectionType?: PricePackagePartSelectionType;
    priceAdjustment?: number | null;
    registrableIds?: string[] | null;
}

export interface PricingQuery {
    eventId?: string;
}

export interface SavePricingCommand {
    eventId?: string;
    packages?: PricePackageDto[] | null;
}

export interface SetRegistrablesPricesCommand {
    eventId?: string;
    registrableId?: string;
    price?: number | null;
    reducedPrice?: number | null;
}

export interface RegistrableDisplayInfo {
    id?: string;
    name?: string;
    nameSecondary?: string | null;
    hasWaitingList?: boolean;
    maximumAllowedImbalance?: number | null;
    maximumDoubleSeats?: number | null;
    maximumSingleSeats?: number | null;
    participants?: SpotDisplayInfo[];
    waitingList?: SpotDisplayInfo[];
    automaticPromotionFromWaitingList?: boolean;
    acceptedLeaders?: number;
    acceptedFollowers?: number;
    leadersOnWaitingList?: number;
    followersOnWaitingList?: number;
}

export interface SpotDisplayInfo {
    leader?: RegistrationDisplayInfo | null;
    follower?: RegistrationDisplayInfo | null;
    isOnWaitingList?: boolean;
    isPartnerRegistration?: boolean;
    joined?: Date | null;
    placeholderPartner?: string | null;
}

export interface RegistrationDisplayInfo {
    id?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    state?: RegistrationState;
}

export interface ParticipantsOfRegistrableQuery {
    eventId?: string;
    registrableId?: string;
}

export interface ProcessReceivedSmsCommand {
    sms?: TwilioSms;
}

export interface TwilioSms {
    accountSid?: string;
    apiVersion?: string;
    body?: string;
    from?: string;
    fromCity?: string;
    fromCountry?: string;
    fromState?: string;
    fromZip?: string;
    messageSid?: string;
    numMedia?: string;
    numSegments?: string;
    smsMessageSid?: string;
    smsSid?: string;
    smsStatus?: string;
    to?: string;
    toCity?: string;
    toCountry?: string;
    toState?: string;
    toZip?: string;
}

export interface SendSmsCommand {
    eventId?: string;
    message?: string;
    registrationId?: string;
}

export interface SmsDisplayItem {
    body?: string;
    date?: Date | null;
    sent?: boolean;
    status?: string;
}

export interface SmsConversationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface IgnorePaymentCommand {
    eventId?: string;
    paymentId?: string;
}

export interface PaymentOverview {
    balance?: BalanceDto | null;
    notFullyPaidRegistrations?: number;
    outstandingAmount?: number;
    paidRegistrations?: number;
    potentialOfOpenSpots?: OpenSpotsPotential[];
    receivedMoney?: number;
}

export interface BalanceDto {
    accountIban?: string;
    balance?: number | null;
    currency?: string;
    date?: Date | null;
}

export interface OpenSpotsPotential {
    name?: string;
    potentialIncome?: number;
    registrableId?: string;
    spotsAvailable?: number;
}

export interface PaymentOverviewQuery {
    eventId?: string;
}

export interface PaymentDisplayItem {
    amount?: number;
    amountAssigned?: number;
    bookingDate?: Date;
    currency?: string | null;
    id?: string;
    info?: string | null;
    paymentSlipId?: string | null;
    reference?: string | null;
    amountRepaid?: number | null;
    settled?: boolean;
    ignore?: boolean;
    message?: string | null;
    debitorName?: string | null;
    creditorName?: string | null;
    creditorIban?: string | null;
}

export interface UnassignedIncomingPaymentsQuery {
    eventId?: string;
    paymentId?: string;
}

export interface UnassignedPayoutsQuery {
    eventId?: string;
    paymentId?: string;
}

export interface CheckIfIncomingPaymentIsSettledCommand {
    incomingPaymentId?: string;
}

export interface CheckIfOutgoingPaymentIsSettledCommand {
    outgoingPaymentId?: string;
}

export interface BookingsOfDay {
    bookingDate?: Date;
    bookings?: PaymentDisplayItem2[];
    balanceAfter?: number | null;
}

export interface PaymentDisplayItem2 {
    id?: string;
    typ?: CreditDebit | null;
    amount?: number;
    charges?: number | null;
    amountAssigned?: number;
    bookingDate?: Date;
    currency?: string | null;
    reference?: string | null;
    amountRepaid?: number | null;
    settled?: boolean;
    ignore?: boolean;
    message?: string | null;
    debitorName?: string | null;
    creditorName?: string | null;
    creditorIban?: string | null;
    paymentSlipId?: string | null;
    balance?: number | null;
}

export enum CreditDebit {
    CRDT = 1,
    DBIT = 2,
}

export interface PaymentsByDayQuery {
    eventId?: string;
    hideIgnored?: boolean;
    hideSettled?: boolean;
    hideIncoming?: boolean;
    hideOutgoing?: boolean;
    searchString?: string | null;
}

export interface PaymentDisplayItem3 {
    id?: string;
    typ?: CreditDebit | null;
    bookingDate?: Date;
    amount?: number;
    charges?: number | null;
    currency?: string | null;
    debitorName?: string | null;
    creditorName?: string | null;
    creditorIban?: string | null;
    message?: string | null;
    reference?: string | null;
    paymentSlipId?: string | null;
    amountAssigned?: number;
    amountRepaid?: number | null;
    settled?: boolean;
    ignore?: boolean;
}

export interface BookingsByStateQuery {
    eventId?: string;
    hideIgnored?: boolean;
    hideSettled?: boolean;
    hideIncoming?: boolean;
    hideOutgoing?: boolean;
}

export interface AssignOutgoingPaymentCommand {
    eventId?: string;
    outgoingPaymentId?: string;
    payoutRequestId?: string | null;
    registrationId?: string | null;
    amount?: number;
    acceptDifference?: boolean;
    acceptDifferenceReason?: string | null;
}

export interface CheckIfPayoutIsConfirmedCommand {
    payoutRequestId?: string;
}

export interface PayoutDisplayItem {
    registrationId?: string;
    firstName?: string | null;
    lastName?: string | null;
    price?: number;
    paid?: number;
    reason?: string | null;
    created?: Date;
    payments?: PaymentDisplayItem4[];
    amount?: number;
    stateText?: string;
    state?: PayoutState;
}

export interface PaymentDisplayItem4 {
    assigned?: number;
    paymentAmount?: number;
    paymentBookingDate?: Date;
    paymentDebitorIban?: string | null;
    paymentDebitorName?: string | null;
    paymentMessage?: string | null;
    paymentInfo?: string | null;
}

export enum PayoutState {
    Requested = 1,
    Sent = 2,
    Confirmed = 3,
}

export interface PayoutQuery {
    eventId?: string;
}

export interface PossiblePayoutAssignment {
    amount?: number;
    amountAssigned?: number;
    amountMatch?: boolean;
    created?: Date;
    currency?: string;
    participant?: string;
    info?: string | null;
    matchScore?: number;
    payoutRequestId?: string;
    paymentId_OpenPosition?: string;
    isOpen?: boolean;
    ibans?: string[];
    registrationId?: string;
}

export interface PossiblePayoutAssignmentQuery {
    eventId?: string;
    paymentId?: string;
}

export interface RefundDisplayItem {
    registrationId?: string;
    firstName?: string;
    lastName?: string;
    price?: number | null;
    paid?: number;
    refundPercentage?: number;
    refund?: number;
    cancellationDate?: Date;
    cancellationReason?: string;
}

export interface RefundsQuery {
    eventId?: string;
}

export interface WillPayAtCheckinCommand {
    eventId?: string;
    registrationId?: string;
}

export interface SavePaymentFileCommand {
    eventId?: string;
    contentType?: string;
    filename?: string;
    fileStream?: MemoryStream;
}

export interface MarshalByRefObject {
}

export interface Stream extends MarshalByRefObject {
    canTimeout?: boolean;
    readTimeout?: number;
    writeTimeout?: number;
}

export interface MemoryStream extends Stream {
    canRead?: boolean;
    canSeek?: boolean;
    canWrite?: boolean;
    capacity?: number;
    length?: number;
    position?: number;
}

export interface PaymentSlipImageQuery {
    eventId?: string;
    paymentSlipId?: string;
}

export interface TryAssignPaymentSlipCommand {
    eventId?: string;
    paymentSlipId?: string;
    reference?: string;
}

export interface FetchBankStatementsFileCommand {
    eventId?: string;
}

export interface ProcessFetchedBankStatementsFileCommand {
    rawBankStatementFileId?: string;
    eventId?: string;
}

export interface DuePaymentItem {
    acceptedMail?: SentMailDto | null;
    email?: string | null;
    firstName?: string | null;
    id?: string;
    lastName?: string | null;
    paid?: number | null;
    phoneNormalized?: string | null;
    price?: number | null;
    receivedAt?: Date;
    reminder1Due?: boolean;
    reminder1Mail?: SentMailDto | null;
    reminder2Due?: boolean;
    reminder2Mail?: SentMailDto | null;
    reminderLevel?: number;
    reminderMailPossible?: boolean;
    reminderSmsPossible?: boolean;
    reminderSmsSent?: Date | null;
    daysSinceLastNotification?: number | null;
    lastNotificationType?: string | null;
}

export interface SentMailDto {
    id?: string;
    sent?: Date;
}

export interface DuePaymentsQuery {
    eventId?: string;
}

export interface SendReminderMailCommand {
    eventId?: string;
    registrationId?: string;
    withhold?: boolean;
}

export interface DifferencesDisplayItem {
    registrationId?: string;
    price?: number;
    amountPaid?: number;
    difference?: number;
    firstName?: string;
    lastName?: string;
    state?: RegistrationState;
    paymentDueMailSent?: Date | null;
    tooMuchPaidMailSent?: Date | null;
}

export interface DifferencesQuery {
    eventId?: string;
}

export interface RefundDifferenceCommand {
    registrationId?: string;
    eventId?: string;
    reason?: string | null;
}

export interface SendPaymentDueMailCommand {
    registrationId?: string;
    eventId?: string;
}

export interface AssignedPaymentsOfRegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface AssignIncomingPaymentCommand {
    acceptDifference?: boolean;
    acceptDifferenceReason?: string | null;
    amount?: number;
    eventId?: string;
    paymentIncomingId?: string;
    registrationId?: string;
}

export interface AssignRepaymentCommand {
    amount?: number;
    eventId?: string;
    incomingPaymentId?: string;
    outgoingPaymentId?: string;
}

export interface PaymentAssignments {
    openAmount?: number;
    type?: PaymentType;
    ignored?: boolean;
    registrationCandidates?: AssignmentCandidateRegistration[] | null;
    existingAssignments?: ExistingAssignment[] | null;
}

export enum PaymentType {
    Incoming = 1,
    Outgoing = 2,
}

export interface AssignmentCandidateRegistration {
    registrationId?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    price?: number;
    isWaitingList?: boolean;
    amountMatch?: boolean;
    amountPaid?: number;
    matchScore?: number;
    paymentId?: string;
    state?: RegistrationState;
}

export interface ExistingAssignment {
    registrationId?: string;
    paymentAssignmentId_Existing?: string | null;
    assignedAmount?: number | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    price?: number;
    isWaitingList?: boolean;
    paymentId?: string;
}

export interface PaymentAssignmentsQuery {
    eventId?: string;
    paymentId?: string;
}

export interface PossibleRepaymentAssignment {
    amount?: number;
    amountUnsettled?: number;
    bookingDate?: Date;
    currency?: string | null;
    debitorName?: string | null;
    info?: string | null;
    matchScore?: number;
    paymentId_Counter?: string;
    paymentId_OpenPosition?: string;
    settled?: boolean;
}

export interface PossibleRepaymentAssignmentQuery {
    eventId?: string;
    paymentId?: string;
}

export interface UnassignPaymentCommand {
    eventId?: string;
    paymentAssignmentId?: string;
}

export interface DeleteMailCommand {
    eventId?: string;
    mailId?: string;
}

export interface MailDisplayItem2 {
    contentHtml?: string;
    created?: Date;
    events?: MailEventDisplayItem[];
    id?: string;
    recipients?: string;
    senderMail?: string;
    senderName?: string;
    state?: MailState | null;
    subject?: string;
    withhold?: boolean;
}

export interface MailEventDisplayItem {
    email?: string;
    state?: MailState;
    stateText?: string;
    when?: Date;
}

export interface MailsOfRegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface MailView {
    id?: string;
    subject?: string | null;
    content?: string | null;
    recipientsEmails?: string | null;
    recipientsNames?: string | null;
    from?: EmailAddress;
    created?: Date;
    recipients?: MailRecipient[] | null;
}

export interface EmailAddress {
    email?: string;
    name?: string;
}

export interface MailRecipient {
    registrationId?: string;
    name?: string;
}

export interface MailViewQuery {
    eventId?: string;
    mailId?: string;
}

export interface PendingMailListItem {
    id?: string;
    recipientsEmails?: string | null;
    recipientsNames?: string | null;
    subject?: string | null;
    contentStart?: string | null;
    created?: Date;
}

export interface PendingMailsQuery {
    eventId?: string;
}

export interface ReleaseAllPendingMailsCommand {
    eventId?: string;
}

export interface ReleaseMailCommand {
    eventId?: string;
    mailId?: string;
}

export interface ResendSentMailsWithoutStateCommand {
    eventId?: string;
}

export interface AutoMailPreview {
    subject?: string | null;
    contentHtml?: string | null;
}

export interface AutoMailPreviewQuery {
    eventId?: string;
    autoMailTemplateId?: string;
    registrationId?: string | null;
}

export interface AutoMailTemplateDisplayItem {
    id?: string;
    type?: MailType;
    subject?: string | null;
    contentHtml?: string | null;
}

export enum MailType {
    SingleRegistrationAccepted = 1,
    SingleRegistrationOnWaitingList = 2,
    RegistrationReceived = 3,
    PartnerRegistrationFirstPartnerAccepted = 11,
    PartnerRegistrationMatchedAndAccepted = 12,
    PartnerRegistrationFirstPartnerOnWaitingList = 13,
    PartnerRegistrationMatchedOnWaitingList = 14,
    SoldOut = 21,
    MoneyOwed = 22,
    TooMuchPaid = 23,
    RegistrationCancelled = 31,
    SingleRegistrationFullyPaid = 41,
    PartnerRegistrationFirstPaid = 42,
    PartnerRegistrationFullyPaid = 43,
    SingleRegistrationFirstReminder = 51,
    SingleRegistrationSecondReminder = 52,
    PartnerRegistrationFirstReminder = 61,
    PartnerRegistrationSecondReminder = 62,
    OptionsForRegistrationsOnWaitingList = 101,
}

export interface AutoMailTemplateQuery {
    eventId?: string;
    mailTemplateId?: string;
}

export interface AutoMailTemplates {
    eventId?: string;
    senderMail?: string | null;
    senderAlias?: string | null;
    groups?: AutoMailTemplateGroup[] | null;
    availableLanguages?: string[];
    singleRegistrationPossible?: boolean;
    partnerRegistrationPossible?: boolean;
}

export interface AutoMailTemplateGroup {
    name?: string | null;
    types?: AutoMailTemplateMetadataType[] | null;
}

export interface AutoMailTemplateMetadataType {
    type?: MailType;
    releaseImmediately?: boolean | null;
    templates?: AutoMailTemplateMetadataLanguage[] | null;
    typeText?: string | null;
}

export interface AutoMailTemplateMetadataLanguage {
    id?: string | null;
    language?: string | null;
    subject?: string | null;
}

export interface AutoMailTemplatesQuery {
    eventId?: string;
}

export interface CreateAutoMailTemplateCommand {
    eventId?: string;
    type?: MailType;
    language?: string;
}

export interface SetReleaseMailCommand {
    eventId?: string;
    type?: MailType;
    releaseImmediately?: boolean;
}

export interface UpdateAutoMailConfigurationCommand {
    eventId?: string;
    senderName?: string | null;
    senderMail?: string | null;
    singleRegistrationPossible?: boolean;
    partnerRegistrationPossible?: boolean;
    availableLanguages?: string[] | null;
}

export interface UpdateAutoMailTemplateCommand {
    eventId?: string;
    templateId?: string;
    subject?: string | null;
    contentHtml?: string | null;
}

export interface SendMailCommand {
    contentHtml?: string;
    contentPlainText?: string;
    mailId?: string;
    sender?: EmailAddress;
    subject?: string;
    to?: EmailAddress[];
}

export interface MailTypeItem {
    bulkMailKey?: string | null;
    type?: MailType | null;
    userText?: string | null;
}

export interface PossibleMailTypesQuery {
    eventId?: string;
    registrationId?: string;
}

export interface FixInvalidAddressCommand {
    eventId?: string;
    newEmailAddress?: string | null;
    oldEmailAddress?: string | null;
    registrationId?: string;
}

export interface InvalidAddress {
    email?: string;
    firstName?: string;
    lastMailSent?: Date | null;
    lastMailState?: string;
    lastName?: string;
    proposals?: string;
    registrationId?: string;
    registrationState?: string;
}

export interface InvalidAddressesQuery {
    eventId?: string;
}

export interface ProblematicEmail {
    email?: string;
    registrationId?: string;
    mails?: NotReceivedMail[];
    participantFirstName?: string | null;
    participantLastName?: string | null;
    severity?: MailDeliverySeverity;
}

export interface NotReceivedMail {
    mailId?: string;
    created?: Date;
    sent?: Date | null;
    recipient?: string | null;
    registrationId?: string;
    state?: MailState | null;
    subject?: string | null;
    stateText?: string | null;
}

export enum MailDeliverySeverity {
    NoneSucceeded = 1,
    SomeSucceeded = 2,
    LastSucceeded = 3,
}

export interface NotReceivedMailsQuery {
    eventId?: string;
    searchString?: string | null;
}

export interface ImportMailsFromImapCommand {
    eventId?: string;
}

export interface ImportMailsFromImapForAllActiveEventsCommand {
}

export interface TryAssignImportedMailCommand {
    importedMailId?: string;
}

export interface ProcessMailEventsCommand {
    rawMailEventsId?: string;
}

export interface PlaceholderDescription {
    key?: string;
    placeholder?: string;
    description?: string;
}

export interface AutoMailPlaceholderQuery {
    mailType?: MailType;
}

export interface ComposeAndSendAutoMailCommand {
    eventId?: string;
    allowDuplicate?: boolean;
    mailType?: MailType;
    registrationId?: string;
    withhold?: boolean;
    data?: any | null;
}

export interface ComposeAndSendBulkMailCommand {
    eventId?: string;
    registrationId?: string;
    allowDuplicate?: boolean;
    bulkMailKey?: string | null;
    mailType?: MailType | null;
    withhold?: boolean;
    data?: any | null;
}

export interface BulkMailTemplates {
    eventId?: string;
    senderMail?: string | null;
    senderAlias?: string | null;
    keys?: BulkMailTemplateKey[] | null;
    availableLanguages?: string[];
}

export interface BulkMailTemplateKey {
    key?: string;
    templates?: BulkMailTemplateMetadataLanguage[] | null;
}

export interface BulkMailTemplateMetadataLanguage {
    id?: string | null;
    language?: string | null;
    subject?: string | null;
}

export interface BulkMailTemplatesQuery {
    eventId?: string;
}

export interface CreateBulkMailsCommand {
    bulkMailKey?: string | null;
    eventId?: string;
}

export interface CreateBulkMailTemplateCommand {
    eventId?: string;
    key?: string | null;
}

export interface DeleteBulkMailTemplateCommand {
    eventId?: string;
    mailTemplateId?: string;
}

export interface PossibleAudience {
    audience?: MailingAudience;
    name?: string;
}

export enum MailingAudience {
    Paid = 1,
    Unpaid = 2,
    WaitingList = 4,
    PredecessorEvent = 8,
    PrePredecessorEvent = 16,
}

export interface PossibleAudiencesQuery {
    eventId?: string;
}

export interface ReleaseBulkMailsCommand {
    bulkMailKey?: string;
    eventId?: string;
}

export interface FroalaKeyQuery {
}

export interface TranslationQuery {
    language?: string | null;
}

export interface DomainEventCatalogItem {
    typeName?: string | null;
    userText?: string;
}

export interface DomainEventCatalogQuery {
}

export interface DomainEventDisplayItem {
    timestamp?: Date | null;
    id?: string;
    type?: string;
    content?: string;
}

export interface DomainEventsQuery {
    eventId?: string;
    types?: string[];
}

export interface SaveDomainEventCommand {
    domainEventId?: string;
    domainEventId_Parent?: string | null;
    eventData?: string;
    eventId?: string | null;
    eventType?: string;
}

export interface StartUpdateReadModelsOfEventCommand {
    eventId?: string | null;
    queryNames?: string[] | null;
}

export interface UpdateReadModelCommand {
    eventId?: string;
    queryName?: string;
    rowId?: string | null;
    dirtyMoment?: Date;
}

export interface HostingOffers {
    dynamicColumns?: string[];
    offers?: HostingOffer[];
}

export interface HostingOffer {
    admittedAt?: Date | null;
    columns?: { [key: string]: string; };
    email?: string;
    firstName?: string;
    language?: string;
    lastName?: string;
    phone?: string;
    registrationId?: string;
    state?: string;
}

export interface HostingOffersQuery {
    eventId?: string;
}

export interface HostingRequests {
    dynamicColumns?: string[];
    requests?: HostingRequest[];
}

export interface HostingRequest {
    admittedAt?: Date | null;
    columns?: { [key: string]: string; };
    email?: string;
    firstName?: string;
    language?: string;
    lastName?: string;
    phone?: string;
    registrationId?: string;
    state?: string;
}

export interface HostingRequestsQuery {
    eventId?: string;
}

export interface CreateEventCommand {
    acronym?: string;
    eventId_Predecessor?: string | null;
    id?: string;
    name?: string;
    copyAccessRights?: boolean;
    copyRegistrables?: boolean;
    copyAutoMailTemplates?: boolean;
    copyBulkMailTemplates?: boolean;
    copyConfigurations?: boolean;
}

export interface EventDetails {
    id?: string;
    name?: string;
    acronym?: string;
    state?: EventState;
}

export interface EventByAcronymQuery {
    eventAcronym?: string | null;
}

export interface EventQuery {
    eventId?: string;
}

export interface OpenRegistrationCommand {
    eventId?: string;
    deleteTestData?: boolean;
}

export interface EventSearchResult {
    id?: string;
    name?: string;
    acronym?: string;
    requestSent?: boolean;
    state?: EventState;
    stateText?: string;
}

export interface SearchEventQuery {
    includeAuthorizedEvents?: boolean;
    includeRequestedEvents?: boolean;
    searchString?: string | null;
}

export interface EventsOfUser {
    authorizedEvents?: EventOfUser[];
    requests?: AccessRequest[];
}

export interface EventOfUser {
    eventId?: string;
    eventName?: string;
    eventAcronym?: string;
    eventState?: EventState;
    eventStateText?: string;
    role?: UserInEventRole;
    roleText?: string;
}

export enum UserInEventRole {
    None = 0,
    Reader = 1,
    Writer = 2,
    Admin = 3,
}

export interface AccessRequest {
    eventId?: string;
    eventName?: string;
    eventAcronym?: string;
    eventState?: EventState;
    eventStateText?: string;
    requestSent?: Date;
}

export interface EventsOfUserQuery {
}

export interface RemoveUserFromEventCommand {
    eventId?: string;
    userId?: string;
}

export interface SetRoleOfUserInEventCommand {
    eventId?: string;
    userId?: string;
    role?: UserInEventRole;
}

export interface RoleDescription {
    role?: UserInEventRole;
    name?: string;
    description?: string;
}

export interface UserInEventRolesQuery {
}

export interface UserInEventDisplayItem {
    eventId?: string;
    role?: UserInEventRole;
    roleText?: string;
    userEmail?: string | null;
    userId?: string;
    userDisplayName?: string;
    userAvatarUrl?: string | null;
}

export interface UsersOfEventQuery {
    eventId?: string;
}

export interface AccessRequestOfEvent {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    avatarUrl?: string | null;
    requestReceived?: Date;
    requestText?: string | null;
}

export interface AccessRequestsOfEventQuery {
    eventId?: string;
    includeDeniedRequests?: boolean;
}

export interface RequestAccessCommand {
    eventId?: string;
    requestText?: string | null;
}

export interface RespondToRequestCommand {
    accessToEventRequestId?: string;
    eventId?: string;
    response?: RequestResponse;
}

export enum RequestResponse {
    Granted = 1,
    Denied = 2,
}

export interface RightsOfUserInEventQuery {
    eventId?: string;
}

export interface UpdateUserInfoCommand {
    provider?: IdentityProvider;
    identifier?: string | null;
}

export enum IdentityProvider {
    Google = 1,
    Microsoft = 2,
    Auth0 = 3,
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}