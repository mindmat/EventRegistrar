//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class Api {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    addSpot_Command(addSpotCommand: AddSpotCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AddSpotCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addSpotCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSpot_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSpot_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAddSpot_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeSpot_Command(removeSpotCommand: RemoveSpotCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RemoveSpotCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeSpotCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSpot_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSpot_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRemoveSpot_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    spotsOfRegistration_Query(spotsOfRegistrationQuery: SpotsOfRegistrationQuery | undefined): Observable<SpotDisplayItem[]> {
        let url_ = this.baseUrl + "/api/SpotsOfRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(spotsOfRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSpotsOfRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSpotsOfRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpotDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpotDisplayItem[]>;
        }));
    }

    protected processSpotsOfRegistration_Query(response: HttpResponseBase): Observable<SpotDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SpotDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registration_Query(registrationQuery: RegistrationQuery | undefined): Observable<RegistrationDisplayItem> {
        let url_ = this.baseUrl + "/api/RegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationDisplayItem>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationDisplayItem>;
        }));
    }

    protected processRegistration_Query(response: HttpResponseBase): Observable<RegistrationDisplayItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationDisplayItem;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    swapFirstLastName_Command(swapFirstLastNameCommand: SwapFirstLastNameCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SwapFirstLastNameCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(swapFirstLastNameCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwapFirstLastName_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwapFirstLastName_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSwapFirstLastName_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchRegistration_Query(searchRegistrationQuery: SearchRegistrationQuery | undefined): Observable<RegistrationMatch[]> {
        let url_ = this.baseUrl + "/api/SearchRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationMatch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationMatch[]>;
        }));
    }

    protected processSearchRegistration_Query(response: HttpResponseBase): Observable<RegistrationMatch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationMatch[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processRawRegistration_Command(processRawRegistrationCommand: ProcessRawRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessRawRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processRawRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessRawRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessRawRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessRawRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setReduction_Command(setReductionCommand: SetReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    allExternalRegistrationIdentifiers_Query(allExternalRegistrationIdentifiersQuery: AllExternalRegistrationIdentifiersQuery | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/AllExternalRegistrationIdentifiersQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(allExternalRegistrationIdentifiersQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllExternalRegistrationIdentifiers_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllExternalRegistrationIdentifiers_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processAllExternalRegistrationIdentifiers_Query(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    recalculatePrice_Command(recalculatePriceCommand: RecalculatePriceCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RecalculatePriceCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(recalculatePriceCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecalculatePrice_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecalculatePrice_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRecalculatePrice_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkin_Query(checkinQuery: CheckinQuery | undefined): Observable<CheckinView> {
        let url_ = this.baseUrl + "/api/CheckinQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkinQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckin_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckin_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckinView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckinView>;
        }));
    }

    protected processCheckin_Query(response: HttpResponseBase): Observable<CheckinView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckinView;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    partyOverview_Query(partyOverviewQuery: PartyOverviewQuery | undefined): Observable<PartyItem[]> {
        let url_ = this.baseUrl + "/api/PartyOverviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(partyOverviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPartyOverview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPartyOverview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PartyItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PartyItem[]>;
        }));
    }

    protected processPartyOverview_Query(response: HttpResponseBase): Observable<PartyItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PartyItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    changeUnmatchedPartnerRegistrationToSingleRegistration_Command(changeUnmatchedPartnerRegistrationToSingleRegistrationCommand: ChangeUnmatchedPartnerRegistrationToSingleRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ChangeUnmatchedPartnerRegistrationToSingleRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changeUnmatchedPartnerRegistrationToSingleRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUnmatchedPartnerRegistrationToSingleRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUnmatchedPartnerRegistrationToSingleRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processChangeUnmatchedPartnerRegistrationToSingleRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    matchPartnerRegistrations_Command(matchPartnerRegistrationsCommand: MatchPartnerRegistrationsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/MatchPartnerRegistrationsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(matchPartnerRegistrationsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMatchPartnerRegistrations_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMatchPartnerRegistrations_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processMatchPartnerRegistrations_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    potentialPartners_Query(potentialPartnersQuery: PotentialPartnersQuery | undefined): Observable<PotentialPartnerMatch[]> {
        let url_ = this.baseUrl + "/api/PotentialPartnersQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(potentialPartnersQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPotentialPartners_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPotentialPartners_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PotentialPartnerMatch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PotentialPartnerMatch[]>;
        }));
    }

    protected processPotentialPartners_Query(response: HttpResponseBase): Observable<PotentialPartnerMatch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PotentialPartnerMatch[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrationsWithUnmatchedPartner_Query(registrationsWithUnmatchedPartnerQuery: RegistrationsWithUnmatchedPartnerQuery | undefined): Observable<PotentialPartnerMatch[]> {
        let url_ = this.baseUrl + "/api/RegistrationsWithUnmatchedPartnerQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationsWithUnmatchedPartnerQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationsWithUnmatchedPartner_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationsWithUnmatchedPartner_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PotentialPartnerMatch[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PotentialPartnerMatch[]>;
        }));
    }

    protected processRegistrationsWithUnmatchedPartner_Query(response: HttpResponseBase): Observable<PotentialPartnerMatch[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PotentialPartnerMatch[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unbindPartnerRegistration_Command(unbindPartnerRegistrationCommand: UnbindPartnerRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UnbindPartnerRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unbindPartnerRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnbindPartnerRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnbindPartnerRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUnbindPartnerRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addIndividualReduction_Command(addIndividualReductionCommand: AddIndividualReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AddIndividualReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addIndividualReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddIndividualReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddIndividualReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAddIndividualReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkRegistrationAfterPayment_Command(checkRegistrationAfterPaymentCommand: CheckRegistrationAfterPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckRegistrationAfterPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkRegistrationAfterPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckRegistrationAfterPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckRegistrationAfterPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckRegistrationAfterPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cancelRegistration_Command(cancelRegistrationCommand: CancelRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CancelRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(cancelRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCancelRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrationFormTypes_Query(registrationFormTypesQuery: RegistrationFormTypesQuery | undefined): Observable<RegistrationFormType[]> {
        let url_ = this.baseUrl + "/api/RegistrationFormTypesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationFormTypesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationFormTypes_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationFormTypes_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFormType[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFormType[]>;
        }));
    }

    protected processRegistrationFormTypes_Query(response: HttpResponseBase): Observable<RegistrationFormType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationFormType[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    availableQuestionMappings_Query(availableQuestionMappingsQuery: AvailableQuestionMappingsQuery | undefined): Observable<AvailableQuestionMapping[]> {
        let url_ = this.baseUrl + "/api/AvailableQuestionMappingsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(availableQuestionMappingsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableQuestionMappings_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableQuestionMappings_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableQuestionMapping[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableQuestionMapping[]>;
        }));
    }

    protected processAvailableQuestionMappings_Query(response: HttpResponseBase): Observable<AvailableQuestionMapping[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableQuestionMapping[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    availableQuestionOptionMappings_Query(availableQuestionOptionMappingsQuery: AvailableQuestionOptionMappingsQuery | undefined): Observable<AvailableQuestionOptionMapping[]> {
        let url_ = this.baseUrl + "/api/AvailableQuestionOptionMappingsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(availableQuestionOptionMappingsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAvailableQuestionOptionMappings_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAvailableQuestionOptionMappings_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AvailableQuestionOptionMapping[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AvailableQuestionOptionMapping[]>;
        }));
    }

    protected processAvailableQuestionOptionMappings_Query(response: HttpResponseBase): Observable<AvailableQuestionOptionMapping[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableQuestionOptionMapping[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveRegistrationFormMappings_Command(saveRegistrationFormMappingsCommand: SaveRegistrationFormMappingsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveRegistrationFormMappingsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveRegistrationFormMappingsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRegistrationFormMappings_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRegistrationFormMappings_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveRegistrationFormMappings_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRegistrationForm_Command(deleteRegistrationFormCommand: DeleteRegistrationFormCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteRegistrationFormCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteRegistrationFormCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegistrationForm_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegistrationForm_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteRegistrationForm_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    pendingRegistrationForm_Query(pendingRegistrationFormQuery: PendingRegistrationFormQuery | undefined): Observable<RegistrationFormItem[]> {
        let url_ = this.baseUrl + "/api/PendingRegistrationFormQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pendingRegistrationFormQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPendingRegistrationForm_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPendingRegistrationForm_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFormItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFormItem[]>;
        }));
    }

    protected processPendingRegistrationForm_Query(response: HttpResponseBase): Observable<RegistrationFormItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationFormItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveRegistrationFormDefinition_Command(saveRegistrationFormDefinitionCommand: SaveRegistrationFormDefinitionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveRegistrationFormDefinitionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveRegistrationFormDefinitionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveRegistrationFormDefinition_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveRegistrationFormDefinition_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveRegistrationFormDefinition_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    formPaths_Query(formPathsQuery: FormPathsQuery | undefined): Observable<RegistrationFormGroup[]> {
        let url_ = this.baseUrl + "/api/FormPathsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(formPathsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFormPaths_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFormPaths_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationFormGroup[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationFormGroup[]>;
        }));
    }

    protected processFormPaths_Query(response: HttpResponseBase): Observable<RegistrationFormGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrationFormGroup[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createRegistrable_Command(createRegistrableCommand: CreateRegistrableCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CreateRegistrableCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRegistrableCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRegistrable_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRegistrable_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCreateRegistrable_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRegistrable_Command(deleteRegistrableCommand: DeleteRegistrableCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteRegistrableCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteRegistrableCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRegistrable_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRegistrable_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteRegistrable_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrablesOverview_Query(registrablesOverviewQuery: RegistrablesOverviewQuery | undefined): Observable<RegistrablesOverview> {
        let url_ = this.baseUrl + "/api/RegistrablesOverviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrablesOverviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrablesOverview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrablesOverview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrablesOverview>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrablesOverview>;
        }));
    }

    protected processRegistrablesOverview_Query(response: HttpResponseBase): Observable<RegistrablesOverview> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrablesOverview;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrables_Query(registrablesQuery: RegistrablesQuery | undefined): Observable<RegistrableDisplayItem[]> {
        let url_ = this.baseUrl + "/api/RegistrablesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrablesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrables_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrables_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrableDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrableDisplayItem[]>;
        }));
    }

    protected processRegistrables_Query(response: HttpResponseBase): Observable<RegistrableDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrableDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setDoubleRegistrableLimits_Command(setDoubleRegistrableLimitsCommand: SetDoubleRegistrableLimitsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetDoubleRegistrableLimitsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setDoubleRegistrableLimitsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDoubleRegistrableLimits_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDoubleRegistrableLimits_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetDoubleRegistrableLimits_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setSingleRegistrableLimits_Command(setSingleRegistrableLimitsCommand: SetSingleRegistrableLimitsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetSingleRegistrableLimitsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setSingleRegistrableLimitsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetSingleRegistrableLimits_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetSingleRegistrableLimits_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetSingleRegistrableLimits_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfRegistrationIsPromoted_Command(checkIfRegistrationIsPromotedCommand: CheckIfRegistrationIsPromotedCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckIfRegistrationIsPromotedCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkIfRegistrationIsPromotedCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfRegistrationIsPromoted_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfRegistrationIsPromoted_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckIfRegistrationIsPromoted_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    tryPromoteFromWaitingList_Command(tryPromoteFromWaitingListCommand: TryPromoteFromWaitingListCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/TryPromoteFromWaitingListCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tryPromoteFromWaitingListCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTryPromoteFromWaitingList_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTryPromoteFromWaitingList_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processTryPromoteFromWaitingList_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrationsOnWaitingList_Query(registrationsOnWaitingListQuery: RegistrationsOnWaitingListQuery | undefined): Observable<WaitingListSpot[]> {
        let url_ = this.baseUrl + "/api/RegistrationsOnWaitingListQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrationsOnWaitingListQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrationsOnWaitingList_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrationsOnWaitingList_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WaitingListSpot[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WaitingListSpot[]>;
        }));
    }

    protected processRegistrationsOnWaitingList_Query(response: HttpResponseBase): Observable<WaitingListSpot[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WaitingListSpot[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setFallbackToPartyPass_Command(setFallbackToPartyPassCommand: SetFallbackToPartyPassCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetFallbackToPartyPassCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setFallbackToPartyPassCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFallbackToPartyPass_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFallbackToPartyPass_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetFallbackToPartyPass_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activateAutomaticPromotion_Command(activateAutomaticPromotionCommand: ActivateAutomaticPromotionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ActivateAutomaticPromotionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activateAutomaticPromotionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateAutomaticPromotion_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateAutomaticPromotion_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processActivateAutomaticPromotion_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deactivateAutomaticPromotion_Command(deactivateAutomaticPromotionCommand: DeactivateAutomaticPromotionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeactivateAutomaticPromotionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deactivateAutomaticPromotionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeactivateAutomaticPromotion_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeactivateAutomaticPromotion_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeactivateAutomaticPromotion_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    registrableTags_Query(registrableTagsQuery: RegistrableTagsQuery | undefined): Observable<RegistrableTagDisplayItem[]> {
        let url_ = this.baseUrl + "/api/RegistrableTagsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registrableTagsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegistrableTags_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegistrableTags_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrableTagDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrableTagDisplayItem[]>;
        }));
    }

    protected processRegistrableTags_Query(response: HttpResponseBase): Observable<RegistrableTagDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrableTagDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteReduction_Command(deleteReductionCommand: DeleteReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveReduction_Command(saveReductionCommand: SaveReductionCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveReductionCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveReductionCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveReduction_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveReduction_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveReduction_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    pricing_Query(pricingQuery: PricingQuery | undefined): Observable<RegistrablePricing[]> {
        let url_ = this.baseUrl + "/api/PricingQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pricingQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPricing_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPricing_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrablePricing[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrablePricing[]>;
        }));
    }

    protected processPricing_Query(response: HttpResponseBase): Observable<RegistrablePricing[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrablePricing[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setRegistrablesPrices_Command(setRegistrablesPricesCommand: SetRegistrablesPricesCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SetRegistrablesPricesCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setRegistrablesPricesCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRegistrablesPrices_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRegistrablesPrices_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSetRegistrablesPrices_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    participantsOfRegistrable_Query(participantsOfRegistrableQuery: ParticipantsOfRegistrableQuery | undefined): Observable<RegistrableDisplayInfo> {
        let url_ = this.baseUrl + "/api/ParticipantsOfRegistrableQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(participantsOfRegistrableQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processParticipantsOfRegistrable_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processParticipantsOfRegistrable_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrableDisplayInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrableDisplayInfo>;
        }));
    }

    protected processParticipantsOfRegistrable_Query(response: HttpResponseBase): Observable<RegistrableDisplayInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegistrableDisplayInfo;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processReceivedSms_Command(processReceivedSmsCommand: ProcessReceivedSmsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessReceivedSmsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processReceivedSmsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessReceivedSms_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessReceivedSms_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessReceivedSms_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendSms_Command(sendSmsCommand: SendSmsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendSmsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendSmsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendSms_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendSms_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendSms_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    smsConversation_Query(smsConversationQuery: SmsConversationQuery | undefined): Observable<SmsDisplayItem[]> {
        let url_ = this.baseUrl + "/api/SmsConversationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(smsConversationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSmsConversation_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSmsConversation_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SmsDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SmsDisplayItem[]>;
        }));
    }

    protected processSmsConversation_Query(response: HttpResponseBase): Observable<SmsDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SmsDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    ignorePayment_Command(ignorePaymentCommand: IgnorePaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/IgnorePaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ignorePaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIgnorePayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIgnorePayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processIgnorePayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentOverview_Query(paymentOverviewQuery: PaymentOverviewQuery | undefined): Observable<PaymentOverview> {
        let url_ = this.baseUrl + "/api/PaymentOverviewQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentOverviewQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentOverview_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentOverview_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentOverview>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentOverview>;
        }));
    }

    protected processPaymentOverview_Query(response: HttpResponseBase): Observable<PaymentOverview> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentOverview;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unassignedIncomingPayments_Query(unassignedIncomingPaymentsQuery: UnassignedIncomingPaymentsQuery | undefined): Observable<PaymentDisplayItem[]> {
        let url_ = this.baseUrl + "/api/UnassignedIncomingPaymentsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unassignedIncomingPaymentsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnassignedIncomingPayments_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnassignedIncomingPayments_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDisplayItem[]>;
        }));
    }

    protected processUnassignedIncomingPayments_Query(response: HttpResponseBase): Observable<PaymentDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unassignedPayouts_Query(unassignedPayoutsQuery: UnassignedPayoutsQuery | undefined): Observable<PaymentDisplayItem[]> {
        let url_ = this.baseUrl + "/api/UnassignedPayoutsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unassignedPayoutsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnassignedPayouts_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnassignedPayouts_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDisplayItem[]>;
        }));
    }

    protected processUnassignedPayouts_Query(response: HttpResponseBase): Observable<PaymentDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfIncomingPaymentIsSettled_Command(checkIfIncomingPaymentIsSettledCommand: CheckIfIncomingPaymentIsSettledCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckIfIncomingPaymentIsSettledCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkIfIncomingPaymentIsSettledCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfIncomingPaymentIsSettled_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfIncomingPaymentIsSettled_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckIfIncomingPaymentIsSettled_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfOutgoingPaymentIsSettled_Command(checkIfOutgoingPaymentIsSettledCommand: CheckIfOutgoingPaymentIsSettledCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckIfOutgoingPaymentIsSettledCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkIfOutgoingPaymentIsSettledCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfOutgoingPaymentIsSettled_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfOutgoingPaymentIsSettled_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckIfOutgoingPaymentIsSettled_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentsByDay_Query(paymentsByDayQuery: PaymentsByDayQuery | undefined): Observable<BookingsOfDay[]> {
        let url_ = this.baseUrl + "/api/PaymentsByDayQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentsByDayQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentsByDay_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentsByDay_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BookingsOfDay[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BookingsOfDay[]>;
        }));
    }

    protected processPaymentsByDay_Query(response: HttpResponseBase): Observable<BookingsOfDay[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BookingsOfDay[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    bookingsByState_Query(bookingsByStateQuery: BookingsByStateQuery | undefined): Observable<PaymentDisplayItem3[]> {
        let url_ = this.baseUrl + "/api/BookingsByStateQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(bookingsByStateQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBookingsByState_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBookingsByState_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentDisplayItem3[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentDisplayItem3[]>;
        }));
    }

    protected processBookingsByState_Query(response: HttpResponseBase): Observable<PaymentDisplayItem3[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentDisplayItem3[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignOutgoingPayment_Command(assignOutgoingPaymentCommand: AssignOutgoingPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AssignOutgoingPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignOutgoingPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignOutgoingPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignOutgoingPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAssignOutgoingPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIfPayoutIsConfirmed_Command(checkIfPayoutIsConfirmedCommand: CheckIfPayoutIsConfirmedCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CheckIfPayoutIsConfirmedCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(checkIfPayoutIsConfirmedCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfPayoutIsConfirmed_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfPayoutIsConfirmed_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCheckIfPayoutIsConfirmed_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    payout_Query(payoutQuery: PayoutQuery | undefined): Observable<PayoutDisplayItem[]> {
        let url_ = this.baseUrl + "/api/PayoutQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(payoutQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayout_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayout_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayoutDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayoutDisplayItem[]>;
        }));
    }

    protected processPayout_Query(response: HttpResponseBase): Observable<PayoutDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PayoutDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possiblePayoutAssignment_Query(possiblePayoutAssignmentQuery: PossiblePayoutAssignmentQuery | undefined): Observable<PossiblePayoutAssignment[]> {
        let url_ = this.baseUrl + "/api/PossiblePayoutAssignmentQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possiblePayoutAssignmentQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossiblePayoutAssignment_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossiblePayoutAssignment_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PossiblePayoutAssignment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PossiblePayoutAssignment[]>;
        }));
    }

    protected processPossiblePayoutAssignment_Query(response: HttpResponseBase): Observable<PossiblePayoutAssignment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PossiblePayoutAssignment[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refunds_Query(refundsQuery: RefundsQuery | undefined): Observable<RefundDisplayItem[]> {
        let url_ = this.baseUrl + "/api/RefundsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refundsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefunds_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefunds_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefundDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefundDisplayItem[]>;
        }));
    }

    protected processRefunds_Query(response: HttpResponseBase): Observable<RefundDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RefundDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    willPayAtCheckin_Command(willPayAtCheckinCommand: WillPayAtCheckinCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/WillPayAtCheckinCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(willPayAtCheckinCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWillPayAtCheckin_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWillPayAtCheckin_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processWillPayAtCheckin_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    savePaymentFile_Command(savePaymentFileCommand: SavePaymentFileCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SavePaymentFileCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(savePaymentFileCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePaymentFile_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePaymentFile_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSavePaymentFile_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentSlipImage_Query(paymentSlipImageQuery: PaymentSlipImageQuery | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PaymentSlipImageQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentSlipImageQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentSlipImage_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentSlipImage_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processPaymentSlipImage_Query(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    tryAssignPaymentSlip_Command(tryAssignPaymentSlipCommand: TryAssignPaymentSlipCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/TryAssignPaymentSlipCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tryAssignPaymentSlipCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTryAssignPaymentSlip_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTryAssignPaymentSlip_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processTryAssignPaymentSlip_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    fetchBankStamentsFile_Command(fetchBankStamentsFileCommand: FetchBankStamentsFileCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/FetchBankStamentsFileCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fetchBankStamentsFileCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchBankStamentsFile_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchBankStamentsFile_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processFetchBankStamentsFile_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processFetchedBankStatementsFile_Command(processFetchedBankStatementsFileCommand: ProcessFetchedBankStatementsFileCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessFetchedBankStatementsFileCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processFetchedBankStatementsFileCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessFetchedBankStatementsFile_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessFetchedBankStatementsFile_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessFetchedBankStatementsFile_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    duePayments_Query(duePaymentsQuery: DuePaymentsQuery | undefined): Observable<DuePaymentItem[]> {
        let url_ = this.baseUrl + "/api/DuePaymentsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(duePaymentsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDuePayments_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDuePayments_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DuePaymentItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DuePaymentItem[]>;
        }));
    }

    protected processDuePayments_Query(response: HttpResponseBase): Observable<DuePaymentItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DuePaymentItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendReminder_Command(sendReminderCommand: SendReminderCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendReminderCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendReminderCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendReminder_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendReminder_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendReminder_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    differences_Query(differencesQuery: DifferencesQuery | undefined): Observable<DifferencesDisplayItem[]> {
        let url_ = this.baseUrl + "/api/DifferencesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(differencesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDifferences_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDifferences_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DifferencesDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DifferencesDisplayItem[]>;
        }));
    }

    protected processDifferences_Query(response: HttpResponseBase): Observable<DifferencesDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DifferencesDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refundDifference_Command(refundDifferenceCommand: RefundDifferenceCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RefundDifferenceCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refundDifferenceCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundDifference_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundDifference_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRefundDifference_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendPaymentDueMail_Command(sendPaymentDueMailCommand: SendPaymentDueMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendPaymentDueMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendPaymentDueMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPaymentDueMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPaymentDueMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendPaymentDueMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignedPaymentsOfRegistration_Query(assignedPaymentsOfRegistrationQuery: AssignedPaymentsOfRegistrationQuery | undefined): Observable<AssignedPaymentDisplayItem[]> {
        let url_ = this.baseUrl + "/api/AssignedPaymentsOfRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignedPaymentsOfRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignedPaymentsOfRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignedPaymentsOfRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AssignedPaymentDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AssignedPaymentDisplayItem[]>;
        }));
    }

    protected processAssignedPaymentsOfRegistration_Query(response: HttpResponseBase): Observable<AssignedPaymentDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssignedPaymentDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignIncomingPayment_Command(assignIncomingPaymentCommand: AssignIncomingPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AssignIncomingPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignIncomingPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignIncomingPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignIncomingPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAssignIncomingPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    assignRepayment_Command(assignRepaymentCommand: AssignRepaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/AssignRepaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(assignRepaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignRepayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignRepayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processAssignRepayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    paymentAssignments_Query(paymentAssignmentsQuery: PaymentAssignmentsQuery | undefined): Observable<PaymentAssignments> {
        let url_ = this.baseUrl + "/api/PaymentAssignmentsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(paymentAssignmentsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentAssignments_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentAssignments_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentAssignments>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentAssignments>;
        }));
    }

    protected processPaymentAssignments_Query(response: HttpResponseBase): Observable<PaymentAssignments> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PaymentAssignments;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possibleRepaymentAssignment_Query(possibleRepaymentAssignmentQuery: PossibleRepaymentAssignmentQuery | undefined): Observable<PossibleRepaymentAssignment[]> {
        let url_ = this.baseUrl + "/api/PossibleRepaymentAssignmentQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possibleRepaymentAssignmentQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossibleRepaymentAssignment_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossibleRepaymentAssignment_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PossibleRepaymentAssignment[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PossibleRepaymentAssignment[]>;
        }));
    }

    protected processPossibleRepaymentAssignment_Query(response: HttpResponseBase): Observable<PossibleRepaymentAssignment[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PossibleRepaymentAssignment[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    unassignPayment_Command(unassignPaymentCommand: UnassignPaymentCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UnassignPaymentCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(unassignPaymentCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnassignPayment_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnassignPayment_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUnassignPayment_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMail_Command(deleteMailCommand: DeleteMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPendingMails_Query(getPendingMailsQuery: GetPendingMailsQuery | undefined): Observable<Mail[]> {
        let url_ = this.baseUrl + "/api/GetPendingMailsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(getPendingMailsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingMails_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingMails_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Mail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Mail[]>;
        }));
    }

    protected processGetPendingMails_Query(response: HttpResponseBase): Observable<Mail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Mail[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    mailsOfRegistration_Query(mailsOfRegistrationQuery: MailsOfRegistrationQuery | undefined): Observable<MailDisplayItem[]> {
        let url_ = this.baseUrl + "/api/MailsOfRegistrationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mailsOfRegistrationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMailsOfRegistration_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMailsOfRegistration_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailDisplayItem[]>;
        }));
    }

    protected processMailsOfRegistration_Query(response: HttpResponseBase): Observable<MailDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MailDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    releaseAllPendingMails_Command(releaseAllPendingMailsCommand: ReleaseAllPendingMailsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ReleaseAllPendingMailsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(releaseAllPendingMailsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseAllPendingMails_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseAllPendingMails_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processReleaseAllPendingMails_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    releaseMail_Command(releaseMailCommand: ReleaseMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ReleaseMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(releaseMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processReleaseMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteMailTemplate_Command(deleteMailTemplateCommand: DeleteMailTemplateCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/DeleteMailTemplateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deleteMailTemplateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMailTemplate_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMailTemplate_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDeleteMailTemplate_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    languages_Query(languagesQuery: LanguagesQuery | undefined): Observable<LanguageItem[]> {
        let url_ = this.baseUrl + "/api/LanguagesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(languagesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLanguages_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLanguages_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageItem[]>;
        }));
    }

    protected processLanguages_Query(response: HttpResponseBase): Observable<LanguageItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LanguageItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    mailTemplates_Query(mailTemplatesQuery: MailTemplatesQuery | undefined): Observable<MailTemplateItem[]> {
        let url_ = this.baseUrl + "/api/MailTemplatesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mailTemplatesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMailTemplates_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMailTemplates_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailTemplateItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailTemplateItem[]>;
        }));
    }

    protected processMailTemplates_Query(response: HttpResponseBase): Observable<MailTemplateItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MailTemplateItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    mailTypes_Query(mailTypesQuery: MailTypesQuery | undefined): Observable<MailTypeItem[]> {
        let url_ = this.baseUrl + "/api/MailTypesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mailTypesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMailTypes_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMailTypes_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailTypeItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailTypeItem[]>;
        }));
    }

    protected processMailTypes_Query(response: HttpResponseBase): Observable<MailTypeItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MailTypeItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveMailTemplate_Command(saveMailTemplateCommand: SaveMailTemplateCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveMailTemplateCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveMailTemplateCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveMailTemplate_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveMailTemplate_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveMailTemplate_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendMail_Command(sendMailCommand: SendMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SendMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sendMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSendMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possibleMailTypes_Query(possibleMailTypesQuery: PossibleMailTypesQuery | undefined): Observable<MailTypeItem[]> {
        let url_ = this.baseUrl + "/api/PossibleMailTypesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possibleMailTypesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossibleMailTypes_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossibleMailTypes_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MailTypeItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MailTypeItem[]>;
        }));
    }

    protected processPossibleMailTypes_Query(response: HttpResponseBase): Observable<MailTypeItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MailTypeItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    fixInvalidAddress_Command(fixInvalidAddressCommand: FixInvalidAddressCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/FixInvalidAddressCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fixInvalidAddressCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFixInvalidAddress_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFixInvalidAddress_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processFixInvalidAddress_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    invalidAddresses_Query(invalidAddressesQuery: InvalidAddressesQuery | undefined): Observable<InvalidAddress[]> {
        let url_ = this.baseUrl + "/api/InvalidAddressesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invalidAddressesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvalidAddresses_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvalidAddresses_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvalidAddress[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvalidAddress[]>;
        }));
    }

    protected processInvalidAddresses_Query(response: HttpResponseBase): Observable<InvalidAddress[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as InvalidAddress[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    notReceivedMails_Query(notReceivedMailsQuery: NotReceivedMailsQuery | undefined): Observable<NotReceivedMail[]> {
        let url_ = this.baseUrl + "/api/NotReceivedMailsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notReceivedMailsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNotReceivedMails_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotReceivedMails_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotReceivedMail[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotReceivedMail[]>;
        }));
    }

    protected processNotReceivedMails_Query(response: HttpResponseBase): Observable<NotReceivedMail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as NotReceivedMail[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importMailsFromImap_Command(importMailsFromImapCommand: ImportMailsFromImapCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ImportMailsFromImapCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importMailsFromImapCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMailsFromImap_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMailsFromImap_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processImportMailsFromImap_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importMailsFromImapForAllActiveEvents_Command(importMailsFromImapForAllActiveEventsCommand: ImportMailsFromImapForAllActiveEventsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ImportMailsFromImapForAllActiveEventsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importMailsFromImapForAllActiveEventsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportMailsFromImapForAllActiveEvents_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportMailsFromImapForAllActiveEvents_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processImportMailsFromImapForAllActiveEvents_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    tryAssignImportedMail_Command(tryAssignImportedMailCommand: TryAssignImportedMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/TryAssignImportedMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tryAssignImportedMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTryAssignImportedMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTryAssignImportedMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processTryAssignImportedMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processMailEvents_Command(processMailEventsCommand: ProcessMailEventsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ProcessMailEventsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(processMailEventsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessMailEvents_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessMailEvents_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processProcessMailEvents_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    composeAndSendMail_Command(composeAndSendMailCommand: ComposeAndSendMailCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ComposeAndSendMailCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(composeAndSendMailCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComposeAndSendMail_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComposeAndSendMail_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processComposeAndSendMail_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createBulkMails_Command(createBulkMailsCommand: CreateBulkMailsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CreateBulkMailsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createBulkMailsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulkMails_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulkMails_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCreateBulkMails_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    possibleAudiences_Query(possibleAudiencesQuery: PossibleAudiencesQuery | undefined): Observable<PossibleAudience[]> {
        let url_ = this.baseUrl + "/api/PossibleAudiencesQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(possibleAudiencesQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPossibleAudiences_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPossibleAudiences_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PossibleAudience[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PossibleAudience[]>;
        }));
    }

    protected processPossibleAudiences_Query(response: HttpResponseBase): Observable<PossibleAudience[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PossibleAudience[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    releaseBulkMails_Command(releaseBulkMailsCommand: ReleaseBulkMailsCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/ReleaseBulkMailsCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(releaseBulkMailsCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReleaseBulkMails_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReleaseBulkMails_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processReleaseBulkMails_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    translation_Query(translationQuery: TranslationQuery | undefined): Observable<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/TranslationQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(translationQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTranslation_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTranslation_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<{ [key: string]: string; }>;
                }
            } else
                return _observableThrow(response_) as any as Observable<{ [key: string]: string; }>;
        }));
    }

    protected processTranslation_Query(response: HttpResponseBase): Observable<{ [key: string]: string; }> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: string; };
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    domainEventCatalog_Query(domainEventCatalogQuery: DomainEventCatalogQuery | undefined): Observable<DomainEventCatalogItem[]> {
        let url_ = this.baseUrl + "/api/DomainEventCatalogQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(domainEventCatalogQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDomainEventCatalog_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDomainEventCatalog_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DomainEventCatalogItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DomainEventCatalogItem[]>;
        }));
    }

    protected processDomainEventCatalog_Query(response: HttpResponseBase): Observable<DomainEventCatalogItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DomainEventCatalogItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    domainEvents_Query(domainEventsQuery: DomainEventsQuery | undefined): Observable<DomainEventDisplayItem[]> {
        let url_ = this.baseUrl + "/api/DomainEventsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(domainEventsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDomainEvents_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDomainEvents_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DomainEventDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DomainEventDisplayItem[]>;
        }));
    }

    protected processDomainEvents_Query(response: HttpResponseBase): Observable<DomainEventDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DomainEventDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveDomainEvent_Command(saveDomainEventCommand: SaveDomainEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/SaveDomainEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(saveDomainEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveDomainEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveDomainEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaveDomainEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    startUpdateAllReadModelsOfEvent_Command(startUpdateAllReadModelsOfEventCommand: StartUpdateAllReadModelsOfEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/StartUpdateAllReadModelsOfEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(startUpdateAllReadModelsOfEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartUpdateAllReadModelsOfEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartUpdateAllReadModelsOfEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processStartUpdateAllReadModelsOfEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateReadModel_Command(updateReadModelCommand: UpdateReadModelCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/UpdateReadModelCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateReadModelCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateReadModel_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateReadModel_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processUpdateReadModel_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    hostingOffers_Query(hostingOffersQuery: HostingOffersQuery | undefined): Observable<HostingOffers> {
        let url_ = this.baseUrl + "/api/HostingOffersQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(hostingOffersQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHostingOffers_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHostingOffers_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostingOffers>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostingOffers>;
        }));
    }

    protected processHostingOffers_Query(response: HttpResponseBase): Observable<HostingOffers> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HostingOffers;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    hostingRequests_Query(hostingRequestsQuery: HostingRequestsQuery | undefined): Observable<HostingRequests> {
        let url_ = this.baseUrl + "/api/HostingRequestsQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(hostingRequestsQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHostingRequests_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHostingRequests_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostingRequests>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostingRequests>;
        }));
    }

    protected processHostingRequests_Query(response: HttpResponseBase): Observable<HostingRequests> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as HostingRequests;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createEvent_Command(createEventCommand: CreateEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/CreateEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processCreateEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    event_Query(eventQuery: EventQuery | undefined): Observable<EventDetails> {
        let url_ = this.baseUrl + "/api/EventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventDetails>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventDetails>;
        }));
    }

    protected processEvent_Query(response: HttpResponseBase): Observable<EventDetails> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EventDetails;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    openRegistration_Command(openRegistrationCommand: OpenRegistrationCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/OpenRegistrationCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(openRegistrationCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOpenRegistration_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOpenRegistration_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processOpenRegistration_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    searchEvent_Query(searchEventQuery: SearchEventQuery | undefined): Observable<EventSearchResult[]> {
        let url_ = this.baseUrl + "/api/SearchEventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchEventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventSearchResult[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventSearchResult[]>;
        }));
    }

    protected processSearchEvent_Query(response: HttpResponseBase): Observable<EventSearchResult[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EventSearchResult[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUserToRoleInEvent_Command(addUserToRoleInEventCommand: AddUserToRoleInEventCommand | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/AddUserToRoleInEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addUserToRoleInEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserToRoleInEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserToRoleInEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processAddUserToRoleInEvent_Command(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    eventsOfUser_Query(eventsOfUserQuery: EventsOfUserQuery | undefined): Observable<UserInEventDisplayItem[]> {
        let url_ = this.baseUrl + "/api/EventsOfUserQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(eventsOfUserQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEventsOfUser_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEventsOfUser_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInEventDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInEventDisplayItem[]>;
        }));
    }

    protected processEventsOfUser_Query(response: HttpResponseBase): Observable<UserInEventDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserInEventDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeUserFromRoleInEvent_Command(removeUserFromRoleInEventCommand: RemoveUserFromRoleInEventCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RemoveUserFromRoleInEventCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(removeUserFromRoleInEventCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromRoleInEvent_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromRoleInEvent_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRemoveUserFromRoleInEvent_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    usersOfEvent_Query(usersOfEventQuery: UsersOfEventQuery | undefined): Observable<UserInEventDisplayItem[]> {
        let url_ = this.baseUrl + "/api/UsersOfEventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(usersOfEventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUsersOfEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersOfEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserInEventDisplayItem[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserInEventDisplayItem[]>;
        }));
    }

    protected processUsersOfEvent_Query(response: HttpResponseBase): Observable<UserInEventDisplayItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserInEventDisplayItem[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    accessRequestsOfEvent_Query(accessRequestsOfEventQuery: AccessRequestsOfEventQuery | undefined): Observable<AccessRequestOfEvent[]> {
        let url_ = this.baseUrl + "/api/AccessRequestsOfEventQuery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(accessRequestsOfEventQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccessRequestsOfEvent_Query(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccessRequestsOfEvent_Query(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessRequestOfEvent[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessRequestOfEvent[]>;
        }));
    }

    protected processAccessRequestsOfEvent_Query(response: HttpResponseBase): Observable<AccessRequestOfEvent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccessRequestOfEvent[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    requestAccess_Command(requestAccessCommand: RequestAccessCommand | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/RequestAccessCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestAccessCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestAccess_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestAccess_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processRequestAccess_Command(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    respondToRequest_Command(respondToRequestCommand: RespondToRequestCommand | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/RespondToRequestCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(respondToRequestCommand);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRespondToRequest_Command(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRespondToRequest_Command(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processRespondToRequest_Command(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Unit;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

/** Represents a void type, since Void is not a valid return type in C#. */
export interface Unit {
}

export interface AddSpotCommand {
    asFollower?: boolean;
    eventId?: string;
    registrableId?: string;
    registrationId?: string;
}

export interface RemoveSpotCommand {
    eventId?: string;
    registrableId?: string;
    registrationId?: string;
}

export interface SpotDisplayItem {
    firstPartnerJoined?: Date;
    id?: string;
    isCore?: boolean;
    isWaitingList?: boolean;
    partnerName?: string | null;
    partnerRegistrationId?: string | null;
    registrableName?: string;
    registrableNameSecondary?: string | null;
    registrableId?: string;
    type?: RegistrableType;
    roleText?: string | null;
}

export enum RegistrableType {
    Single = 1,
    Double = 2,
}

export interface SpotsOfRegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface RegistrationDisplayItem {
    id?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    isReduced?: boolean;
    isWaitingList?: boolean | null;
    language?: string | null;
    paid?: number;
    partnerId?: string | null;
    partnerOriginal?: string | null;
    partnerName?: string | null;
    phoneNormalized?: string | null;
    phoneFormatted?: string | null;
    price?: number | null;
    receivedAt?: Date;
    remarks?: string | null;
    reminderLevel?: number;
    smsCount?: number;
    soldOutMessage?: string | null;
    status?: RegistrationState;
    statusText?: string;
    willPayAtCheckin?: boolean;
    fallbackToPartyPass?: boolean | null;
    spots?: SpotDisplayItem[] | null;
    payments?: AssignedPaymentDisplayItem[] | null;
}

export enum RegistrationState {
    Received = 1,
    Paid = 2,
    Cancelled = 4,
}

export interface AssignedPaymentDisplayItem {
    amount?: number;
    bookingDate?: Date;
    currency?: string | null;
    paymentAssignmentId?: string;
}

export interface RegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface SwapFirstLastNameCommand {
    eventId?: string;
    registrationId?: string;
}

export interface RegistrationMatch {
    registrationId?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    isWaitingList?: boolean;
    state?: RegistrationState;
    amount?: number;
    amountPaid?: number;
    stateText?: string;
    spots?: SpotShort[];
    receivedAt?: Date;
}

export interface SpotShort {
    name?: string;
    secondary?: string | null;
    isWaitingList?: boolean;
}

export interface SearchRegistrationQuery {
    eventId?: string;
    searchString?: string | null;
    states?: RegistrationState[] | null;
}

export interface ProcessRawRegistrationCommand {
    rawRegistrationId?: string;
}

export interface SetReductionCommand {
    eventId?: string;
    isReduced?: boolean;
    registrationId?: string;
}

export interface AllExternalRegistrationIdentifiersQuery {
    registrationFormExternalIdentifier?: string;
}

export interface RecalculatePriceCommand {
    registrationId?: string;
}

export interface CheckinView {
    dynamicHeaders?: string[];
    items?: CheckinViewItem[];
}

export interface CheckinViewItem {
    admittedAt?: Date | null;
    columns?: { [key: string]: string; };
    email?: string;
    firstName?: string;
    lastName?: string;
    registrationId?: string;
    status?: string;
    unsettledAmount?: number;
}

export interface CheckinQuery {
    eventId?: string;
}

export interface PartyItem {
    details?: PartyDetailItem[];
    direct?: number;
    id?: string;
    name?: string;
    partyPassFallbacksOnWaitingList?: number;
    potential?: number;
    potentialOnWaitingList?: number;
    sortyKey?: number | null;
    total?: number;
}

export interface PartyDetailItem {
    id?: string;
    name?: string;
    participants?: number;
    potential?: number;
}

export interface PartyOverviewQuery {
    eventId?: string;
}

export interface ChangeUnmatchedPartnerRegistrationToSingleRegistrationCommand {
    eventId?: string;
    registrationId?: string;
}

export interface MatchPartnerRegistrationsCommand {
    eventId?: string;
    registrationId1?: string;
    registrationId2?: string;
}

export interface PotentialPartnerMatch {
    email?: string;
    firstName?: string;
    isWaitingList?: boolean;
    lastName?: string;
    matchedPartner?: string;
    partner?: string;
    registrables?: string[];
    registrationId?: string;
    registrationId_Partner?: string | null;
    state?: string;
}

export interface PotentialPartnersQuery {
    eventId?: string;
    registrationId?: string;
    searchString?: string;
}

export interface RegistrationsWithUnmatchedPartnerQuery {
    eventId?: string;
}

export interface UnbindPartnerRegistrationCommand {
    eventId?: string;
    registrationId?: string;
}

export interface AddIndividualReductionCommand {
    amount?: number;
    eventId?: string;
    reason?: string;
    reductionId?: string;
    registrationId?: string;
}

export interface CheckRegistrationAfterPaymentCommand {
    registrationId?: string;
}

export interface CancelRegistrationCommand {
    eventId?: string;
    ignorePayments?: boolean;
    reason?: string;
    refundPercentage?: number;
    registrationId?: string;
    received?: Date | null;
}

export interface RegistrationFormType {
    pathType?: FormPathType;
    name?: string;
}

export enum FormPathType {
    Single = 1,
    Partner = 2,
}

export interface RegistrationFormTypesQuery {
}

export interface AvailableQuestionMapping {
    type?: QuestionMappingType;
    text?: string;
}

export enum QuestionMappingType {
    FirstName = 1,
    LastName = 2,
    EMail = 3,
    Phone = 4,
    Town = 5,
    Remarks = 6,
    Partner = 10,
}

export interface AvailableQuestionMappingsQuery {
    eventId?: string;
}

export interface AvailableQuestionOptionMapping {
    combinedId?: string;
    id?: string | null;
    type?: MappingType | null;
    language?: string | null;
    name?: string | null;
}

export enum MappingType {
    SingleRegistrable = 1,
    PartnerRegistrable = 2,
    PartnerRegistrableLeader = 3,
    PartnerRegistrableFollower = 4,
    Language = 5,
    Reduction = 6,
    RoleLeader = 7,
    RoleFollower = 8,
}

export interface AvailableQuestionOptionMappingsQuery {
    eventId?: string;
}

export interface SaveRegistrationFormMappingsCommand {
    eventId?: string;
    mappings?: RegistrationFormGroup;
    formId?: string;
}

export interface RegistrationFormGroup {
    id?: string;
    title?: string | null;
    sections?: FormSection[];
}

export interface FormSection {
    name?: string | null;
    sortKey?: number;
    questions?: QuestionMappingDisplayItem[];
}

export interface QuestionMappingDisplayItem {
    id?: string;
    question?: string | null;
    type?: QuestionType;
    options?: QuestionOptionMappingDisplayItem[] | null;
    sortKey?: number;
    mappable?: boolean;
    mapping?: QuestionMappingType | null;
}

export enum QuestionType {
    Checkbox = 1,
    CheckboxGrid = 2,
    Date = 3,
    Datetime = 4,
    Duration = 5,
    Grid = 6,
    Image = 7,
    List = 8,
    MultipleChoice = 9,
    PageBreak = 10,
    ParagraphText = 11,
    Scale = 12,
    SectionHeader = 13,
    Text = 14,
    Time = 15,
}

export interface QuestionOptionMappingDisplayItem {
    id?: string;
    answer?: string | null;
    mappedRegistrables?: AvailableQuestionOptionMapping[] | null;
}

export interface DeleteRegistrationFormCommand {
    eventId?: string;
    registrationFormId?: string;
}

export interface RegistrationFormItem {
    registrationFormId?: string | null;
    externalIdentifier?: string;
    state?: State;
    title?: string;
    lastImport?: Date | null;
    pendingRawFormCreated?: Date | null;
    pendingRawFormId?: string | null;
    deletable?: boolean;
}

export enum State {
    Setup = 1,
    RegistrationOpen = 2,
    RegistrationClosed = 3,
    Finished = 4,
}

export interface PendingRegistrationFormQuery {
    eventId?: string;
}

export interface SaveRegistrationFormDefinitionCommand {
    eventId?: string;
    formId?: string;
}

export interface FormPathsQuery {
    eventId?: string;
}

export interface CreateRegistrableCommand {
    parameters?: CreateRegistrableParameters;
    eventId?: string;
}

export interface CreateRegistrableParameters {
    id?: string;
    name?: string;
    isDoubleRegistrable?: boolean;
}

export interface DeleteRegistrableCommand {
    eventId?: string;
    registrableId?: string;
}

export interface RegistrablesOverview {
    singleRegistrables?: SingleRegistrableDisplayItem[];
    doubleRegistrables?: DoubleRegistrableDisplayItem[];
}

export interface SingleRegistrableDisplayItem {
    id?: string;
    name?: string;
    nameSecondary?: string | null;
    tag?: string | null;
    accepted?: number;
    onWaitingList?: number | null;
    spotsAvailable?: number | null;
    hasWaitingList?: boolean;
    isDeletable?: boolean;
    automaticPromotionFromWaitingList?: boolean;
    class?: SpotState[];
    waitingList?: SpotState[];
}

export enum SpotState {
    Available = 1,
    Reserved = 2,
    Registered = 3,
    Paid = 4,
}

export interface DoubleRegistrableDisplayItem {
    id?: string;
    name?: string;
    nameSecondary?: string | null;
    tag?: string | null;
    couplesOnWaitingList?: number;
    followersAccepted?: number;
    followersOnWaitingList?: number;
    leadersAccepted?: number;
    leadersOnWaitingList?: number;
    maximumAllowedImbalance?: number | null;
    spotsAvailable?: number | null;
    hasWaitingList?: boolean;
    isDeletable?: boolean;
    automaticPromotionFromWaitingList?: boolean;
    class?: DoubleSpotState[];
    waitingList?: DoubleSpotState[];
}

export interface DoubleSpotState {
    leader?: SpotState;
    follower?: SpotState;
    linked?: boolean;
}

export interface RegistrablesOverviewQuery {
    eventId?: string;
}

export interface RegistrableDisplayItem {
    hasWaitingList?: boolean;
    id?: string;
    isDoubleRegistrable?: boolean;
    name?: string;
    showInMailListOrder?: number | null;
    sortKey?: number | null;
}

export interface RegistrablesQuery {
    eventId?: string;
}

export interface SetDoubleRegistrableLimitsCommand {
    eventId?: string;
    maximumCouples?: number;
    maximumImbalance?: number;
    registrableId?: string;
}

export interface SetSingleRegistrableLimitsCommand {
    eventId?: string;
    maximumParticipants?: number;
    registrableId?: string;
}

export interface CheckIfRegistrationIsPromotedCommand {
    registrationId?: string;
}

export interface TryPromoteFromWaitingListCommand {
    eventId?: string;
    registrableId?: string;
    registrationId?: string | null;
}

export interface WaitingListSpot {
    follower?: WaitingListRegistration;
    isOnWaitingList?: boolean;
    isPartnerRegistration?: boolean;
    joined?: Date | null;
    leader?: WaitingListRegistration;
    placeholderPartner?: string;
    registrableName?: string;
}

export interface WaitingListRegistration {
    firstName?: string;
    id?: string | null;
    lastName?: string;
    optionsSent?: boolean;
    state?: RegistrationState;
}

export interface RegistrationsOnWaitingListQuery {
    eventId?: string;
}

export interface SetFallbackToPartyPassCommand {
    eventId?: string;
    registrationId?: string;
}

export interface ActivateAutomaticPromotionCommand {
    eventId?: string;
    tryPromoteImmediately?: boolean;
    registrableId?: string;
}

export interface DeactivateAutomaticPromotionCommand {
    eventId?: string;
    registrableId?: string;
}

export interface RegistrableTagDisplayItem {
    tagId?: string;
    text?: string;
    tag?: string;
    sortKey?: number;
}

export interface RegistrableTagsQuery {
    eventId?: string;
}

export interface DeleteReductionCommand {
    registrableId?: string;
    reductionId?: string;
    eventId?: string;
}

export interface SaveReductionCommand {
    registrableId?: string;
    reductionId?: string;
    amount?: number;
    registrableId1_ReductionActivatedIfCombinedWith?: string | null;
    registrableId2_ReductionActivatedIfCombinedWith?: string | null;
    eventId?: string;
}

export interface RegistrablePricing {
    registrableId?: string;
    price?: number | null;
    reducedPrice?: number | null;
    registrableName?: string;
    reductions?: PricingReduction[];
}

export interface PricingReduction {
    id?: string;
    amount?: number;
    registrableId1_ReductionActivatedIfCombinedWith?: string | null;
    registrableId2_ReductionActivatedIfCombinedWith?: string | null;
}

export interface PricingQuery {
    eventId?: string;
}

export interface SetRegistrablesPricesCommand {
    eventId?: string;
    registrableId?: string;
    price?: number | null;
    reducedPrice?: number | null;
}

export interface RegistrableDisplayInfo {
    name?: string;
    nameSecondary?: string | null;
    hasWaitingList?: boolean;
    maximumAllowedImbalance?: number | null;
    maximumDoubleSeats?: number | null;
    maximumSingleSeats?: number | null;
    participants?: SpotDisplayInfo[];
    waitingList?: SpotDisplayInfo[];
    automaticPromotionFromWaitingList?: boolean;
    acceptedLeaders?: number;
    acceptedFollowers?: number;
    leadersOnWaitingList?: number;
    followersOnWaitingList?: number;
}

export interface SpotDisplayInfo {
    leader?: RegistrationDisplayInfo | null;
    follower?: RegistrationDisplayInfo | null;
    isOnWaitingList?: boolean;
    isPartnerRegistration?: boolean;
    joined?: Date | null;
    placeholderPartner?: string | null;
}

export interface RegistrationDisplayInfo {
    id?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    state?: RegistrationState;
}

export interface ParticipantsOfRegistrableQuery {
    eventId?: string;
    registrableId?: string;
}

export interface ProcessReceivedSmsCommand {
    sms?: TwilioSms;
}

export interface TwilioSms {
    accountSid?: string;
    apiVersion?: string;
    body?: string;
    from?: string;
    fromCity?: string;
    fromCountry?: string;
    fromState?: string;
    fromZip?: string;
    messageSid?: string;
    numMedia?: string;
    numSegments?: string;
    smsMessageSid?: string;
    smsSid?: string;
    smsStatus?: string;
    to?: string;
    toCity?: string;
    toCountry?: string;
    toState?: string;
    toZip?: string;
}

export interface SendSmsCommand {
    eventId?: string;
    message?: string;
    registrationId?: string;
}

export interface SmsDisplayItem {
    body?: string;
    date?: Date | null;
    sent?: boolean;
    status?: string;
}

export interface SmsConversationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface IgnorePaymentCommand {
    eventId?: string;
    paymentId?: string;
}

export interface PaymentOverview {
    balance?: BalanceDto | null;
    notFullyPaidRegistrations?: number;
    outstandingAmount?: number;
    paidRegistrations?: number;
    potentialOfOpenSpots?: OpenSpotsPotential[];
    receivedMoney?: number;
}

export interface BalanceDto {
    accountIban?: string;
    balance?: number | null;
    currency?: string;
    date?: Date | null;
}

export interface OpenSpotsPotential {
    name?: string;
    potentialIncome?: number;
    registrableId?: string;
    spotsAvailable?: number;
}

export interface PaymentOverviewQuery {
    eventId?: string;
}

export interface PaymentDisplayItem {
    amount?: number;
    amountAssigned?: number;
    bookingDate?: Date;
    currency?: string | null;
    id?: string;
    info?: string | null;
    paymentSlipId?: string | null;
    reference?: string | null;
    amountRepaid?: number | null;
    settled?: boolean;
    ignore?: boolean;
    message?: string | null;
    debitorName?: string | null;
    creditorName?: string | null;
    creditorIban?: string | null;
}

export interface UnassignedIncomingPaymentsQuery {
    eventId?: string;
    paymentId?: string;
}

export interface UnassignedPayoutsQuery {
    eventId?: string;
    paymentId?: string;
}

export interface CheckIfIncomingPaymentIsSettledCommand {
    incomingPaymentId?: string;
}

export interface CheckIfOutgoingPaymentIsSettledCommand {
    outgoingPaymentId?: string;
}

export interface BookingsOfDay {
    bookingDate?: Date;
    bookings?: PaymentDisplayItem2[];
    balanceAfter?: number | null;
}

export interface PaymentDisplayItem2 {
    id?: string;
    typ?: CreditDebit | null;
    amount?: number;
    charges?: number | null;
    amountAssigned?: number;
    bookingDate?: Date;
    currency?: string | null;
    reference?: string | null;
    amountRepaid?: number | null;
    settled?: boolean;
    ignore?: boolean;
    message?: string | null;
    debitorName?: string | null;
    creditorName?: string | null;
    creditorIban?: string | null;
    paymentSlipId?: string | null;
    balance?: number | null;
}

export enum CreditDebit {
    CRDT = 1,
    DBIT = 2,
}

export interface PaymentsByDayQuery {
    eventId?: string;
    hideIgnored?: boolean;
    hideSettled?: boolean;
    hideIncoming?: boolean;
    hideOutgoing?: boolean;
    searchString?: string | null;
}

export interface PaymentDisplayItem3 {
    id?: string;
    typ?: CreditDebit | null;
    bookingDate?: Date;
    amount?: number;
    charges?: number | null;
    currency?: string | null;
    debitorName?: string | null;
    creditorName?: string | null;
    creditorIban?: string | null;
    message?: string | null;
    reference?: string | null;
    paymentSlipId?: string | null;
    amountAssigned?: number;
    amountRepaid?: number | null;
    settled?: boolean;
    ignore?: boolean;
}

export interface BookingsByStateQuery {
    eventId?: string;
    hideIgnored?: boolean;
    hideSettled?: boolean;
    hideIncoming?: boolean;
    hideOutgoing?: boolean;
}

export interface AssignOutgoingPaymentCommand {
    eventId?: string;
    outgoingPaymentId?: string;
    payoutRequestId?: string | null;
    registrationId?: string | null;
    amount?: number;
    acceptDifference?: boolean;
    acceptDifferenceReason?: string | null;
}

export interface CheckIfPayoutIsConfirmedCommand {
    payoutRequestId?: string;
}

export interface PayoutDisplayItem {
    registrationId?: string;
    firstName?: string | null;
    lastName?: string | null;
    price?: number;
    paid?: number;
    reason?: string | null;
    created?: Date;
    payments?: PaymentDisplayItem4[];
    amount?: number;
    stateText?: string;
    state?: PayoutState;
}

export interface PaymentDisplayItem4 {
    assigned?: number;
    paymentAmount?: number;
    paymentBookingDate?: Date;
    paymentDebitorIban?: string | null;
    paymentDebitorName?: string | null;
    paymentMessage?: string | null;
    paymentInfo?: string | null;
}

export enum PayoutState {
    Requested = 1,
    Sent = 2,
    Confirmed = 3,
}

export interface PayoutQuery {
    eventId?: string;
}

export interface PossiblePayoutAssignment {
    amount?: number;
    amountAssigned?: number;
    amountMatch?: boolean;
    created?: Date;
    currency?: string;
    participant?: string;
    info?: string | null;
    matchScore?: number;
    payoutRequestId?: string;
    paymentId_OpenPosition?: string;
    isOpen?: boolean;
    ibans?: string[];
    registrationId?: string;
}

export interface PossiblePayoutAssignmentQuery {
    eventId?: string;
    paymentId?: string;
}

export interface RefundDisplayItem {
    registrationId?: string;
    firstName?: string;
    lastName?: string;
    price?: number | null;
    paid?: number;
    refundPercentage?: number;
    refund?: number;
    cancellationDate?: Date;
    cancellationReason?: string;
}

export interface RefundsQuery {
    eventId?: string;
}

export interface WillPayAtCheckinCommand {
    eventId?: string;
    registrationId?: string;
}

export interface SavePaymentFileCommand {
    eventId?: string;
    contentType?: string;
    filename?: string;
    fileStream?: MemoryStream;
}

export interface MarshalByRefObject {
}

export interface Stream extends MarshalByRefObject {
    canTimeout?: boolean;
    readTimeout?: number;
    writeTimeout?: number;
}

export interface MemoryStream extends Stream {
    canRead?: boolean;
    canSeek?: boolean;
    canWrite?: boolean;
    capacity?: number;
    length?: number;
    position?: number;
}

export interface PaymentSlipImageQuery {
    eventId?: string;
    paymentSlipId?: string;
}

export interface TryAssignPaymentSlipCommand {
    eventId?: string;
    paymentSlipId?: string;
    reference?: string;
}

export interface FetchBankStamentsFileCommand {
    eventId?: string;
}

export interface ProcessFetchedBankStatementsFileCommand {
    rawBankStatementFileId?: string;
    eventId?: string;
}

export interface DuePaymentItem {
    acceptedMail?: SentMailDto | null;
    email?: string | null;
    firstName?: string | null;
    id?: string;
    lastName?: string | null;
    paid?: number | null;
    phoneNormalized?: string | null;
    price?: number | null;
    receivedAt?: Date;
    reminder1Due?: boolean;
    reminder1Mail?: SentMailDto | null;
    reminder2Due?: boolean;
    reminder2Mail?: SentMailDto | null;
    reminderLevel?: number;
    reminderSmsPossible?: boolean;
    reminderSmsSent?: Date | null;
    daysSinceLastNotification?: number | null;
    lastNotificationType?: string | null;
}

export interface SentMailDto {
    id?: string;
    sent?: Date;
}

export interface DuePaymentsQuery {
    eventId?: string;
}

export interface SendReminderCommand {
    eventId?: string;
    registrationId?: string;
    withhold?: boolean;
}

export interface DifferencesDisplayItem {
    registrationId?: string;
    price?: number;
    amountPaid?: number;
    difference?: number;
    firstName?: string;
    lastName?: string;
    state?: RegistrationState;
    paymentDueMailSent?: Date | null;
    tooMuchPaidMailSent?: Date | null;
}

export interface DifferencesQuery {
    eventId?: string;
}

export interface RefundDifferenceCommand {
    registrationId?: string;
    eventId?: string;
    reason?: string | null;
}

export interface SendPaymentDueMailCommand {
    registrationId?: string;
    eventId?: string;
}

export interface AssignedPaymentsOfRegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface AssignIncomingPaymentCommand {
    acceptDifference?: boolean;
    acceptDifferenceReason?: string | null;
    amount?: number;
    eventId?: string;
    paymentIncomingId?: string;
    registrationId?: string;
}

export interface AssignRepaymentCommand {
    amount?: number;
    eventId?: string;
    incomingPaymentId?: string;
    outgoingPaymentId?: string;
}

export interface PaymentAssignments {
    openAmount?: number;
    type?: PaymentType;
    registrationCandidates?: AssignmentCandidateRegistration[] | null;
    existingAssignments?: ExistingAssignment[] | null;
}

export enum PaymentType {
    Incoming = 1,
    Outgoing = 2,
}

export interface AssignmentCandidateRegistration {
    registrationId?: string;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    price?: number;
    isWaitingList?: boolean;
    amountMatch?: boolean;
    amountPaid?: number;
    matchScore?: number;
    paymentId?: string;
    state?: RegistrationState;
}

export interface ExistingAssignment {
    registrationId?: string;
    paymentAssignmentId_Existing?: string | null;
    assignedAmount?: number | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    price?: number;
    isWaitingList?: boolean;
    paymentId?: string;
}

export interface PaymentAssignmentsQuery {
    eventId?: string;
    paymentId?: string;
}

export interface PossibleRepaymentAssignment {
    amount?: number;
    amountUnsettled?: number;
    bookingDate?: Date;
    currency?: string | null;
    debitorName?: string | null;
    info?: string | null;
    matchScore?: number;
    paymentId_Counter?: string;
    paymentId_OpenPosition?: string;
    settled?: boolean;
}

export interface PossibleRepaymentAssignmentQuery {
    eventId?: string;
    paymentId?: string;
}

export interface UnassignPaymentCommand {
    eventId?: string;
    paymentAssignmentId?: string;
}

export interface DeleteMailCommand {
    eventId?: string;
    mailId?: string;
}

export interface Entity {
    id?: string;
    rowVersion?: string;
}

export interface Mail extends Entity {
    eventId?: string | null;
    event?: Event | null;
    mailTemplateId?: string | null;
    mailTemplate?: MailTemplate | null;
    events?: MailEvent[] | null;
    registrations?: MailToRegistration[] | null;
    senderMail?: string | null;
    senderName?: string | null;
    subject?: string | null;
    recipients?: string | null;
    contentHtml?: string | null;
    contentPlainText?: string | null;
    created?: Date;
    sendGridMessageId?: string | null;
    sent?: Date | null;
    state?: MailState | null;
    type?: MailType | null;
    withhold?: boolean;
    discarded?: boolean;
    bulkMailKey?: string | null;
    dataTypeFullName?: string | null;
    dataJson?: string | null;
}

export interface Event extends Entity {
    predecessorEventId?: string | null;
    predecessorEvent?: Event | null;
    accessRequests?: AccessToEventRequest[] | null;
    configurations?: EventConfiguration[] | null;
    registrables?: Registrable[] | null;
    registrations?: Registration[] | null;
    users?: UserInEvent[] | null;
    name?: string;
    state?: State;
    acronym?: string;
    currency?: string | null;
    accountIban?: string | null;
}

export interface AccessToEventRequest extends Entity {
    eventId?: string;
    event?: Event | null;
    userId_Requestor?: string | null;
    user_Requestor?: User | null;
    userId_Responder?: string | null;
    user_Responder?: User | null;
    identifier?: string | null;
    identityProvider?: IdentityProvider;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    requestReceived?: Date;
    requestText?: string | null;
    response?: RequestResponse | null;
    responseText?: string | null;
}

export interface User extends Entity {
    events?: UserInEvent[] | null;
    identityProvider?: IdentityProvider;
    identityProviderUserIdentifier?: string | null;
    email?: string | null;
    firstName?: string | null;
    lastName?: string | null;
}

export interface UserInEvent extends Entity {
    event?: Event | null;
    eventId?: string;
    user?: User | null;
    userId?: string;
    role?: UserInEventRole;
}

export enum UserInEventRole {
    None = 0,
    Reader = 1,
    Writer = 2,
    Admin = 3,
}

export enum IdentityProvider {
    Google = 1,
    Microsoft = 2,
}

export enum RequestResponse {
    Granted = 1,
    Denied = 2,
}

export interface EventConfiguration extends Entity {
    event?: Event | null;
    eventId?: string;
    type?: string;
    valueJson?: string;
}

export interface Registrable extends Entity {
    eventId?: string;
    event?: Event | null;
    compositions?: RegistrableComposition[] | null;
    questionOptionMappings?: QuestionOptionMapping[] | null;
    reductions?: Reduction[] | null;
    spots?: Seat[] | null;
    name?: string;
    nameSecondary?: string | null;
    hasWaitingList?: boolean;
    automaticPromotionFromWaitingList?: boolean;
    isCore?: boolean;
    maximumAllowedImbalance?: number | null;
    maximumDoubleSeats?: number | null;
    maximumSingleSeats?: number | null;
    price?: number | null;
    reducedPrice?: number | null;
    showInMailListOrder?: number | null;
    checkinListColumn?: string | null;
    tag?: string | null;
    type?: RegistrableType;
}

export interface RegistrableComposition extends Entity {
    registrableId?: string;
    registrable?: Registrable | null;
    registrableId_Contains?: string;
    registrable_Contains?: Registrable | null;
}

export interface QuestionOptionMapping extends Entity {
    questionOptionId?: string;
    questionOption?: QuestionOption | null;
    registrableId?: string | null;
    registrable?: Registrable | null;
    type?: MappingType | null;
    language?: string | null;
}

export interface QuestionOption extends Entity {
    questionId?: string;
    question?: Question | null;
    mappings?: QuestionOptionMapping[] | null;
    answer?: string;
}

export interface Question extends Entity {
    registrationFormId?: string;
    registrationForm?: RegistrationForm | null;
    questionOptions?: QuestionOption[] | null;
    externalId?: number;
    index?: number;
    type?: QuestionType;
    title?: string;
    section?: string | null;
    mapping?: QuestionMappingType | null;
    templateKey?: string | null;
}

export interface RegistrationForm extends Entity {
    eventId?: string;
    event?: Event | null;
    questions?: Question[] | null;
    formPaths?: FormPath[] | null;
    externalIdentifier?: string;
    state?: State;
    title?: string | null;
}

export interface FormPath extends Entity {
    registrationFormId?: string;
    registrationForm?: RegistrationForm | null;
    description?: string | null;
    type?: FormPathType;
    configurationJson?: string;
    singleConfiguration?: SingleRegistrationProcessConfiguration | null;
    partnerConfiguration?: PartnerRegistrationProcessConfiguration | null;
}

export interface SingleRegistrationProcessConfiguration {
    id?: string;
    registrationFormId?: string;
    description?: string | null;
    type?: FormPathType;
    languageMappings?: LanguageMapping[] | null;
    questionId_Email?: string;
    questionId_FirstName?: string;
    questionId_LastName?: string;
    questionId_Phone?: string | null;
    questionId_Remarks?: string | null;
    questionOptionId_Follower?: string | null;
    questionOptionId_Leader?: string | null;
    questionOptionId_Reduction?: string | null;
    questionOptionId_Trigger?: string | null;
    mappingsToRegistrables?: IQuestionMapping[] | null;
}

export interface LanguageMapping {
    questionOptionId?: string;
    language?: string;
}

export interface IQuestionMapping {
    questionOptionId?: string;
    registrableId?: string;
}

export interface PartnerRegistrationProcessConfiguration {
    id?: string;
    registrationFormId?: string;
    description?: string | null;
    type?: FormPathType;
    languageMappings?: LanguageMapping[] | null;
    questionId_Follower_Email?: string;
    questionId_Follower_FirstName?: string;
    questionId_Follower_LastName?: string;
    questionId_Follower_Phone?: string | null;
    questionId_Leader_Email?: string;
    questionId_Leader_FirstName?: string;
    questionId_Leader_LastName?: string;
    questionId_Leader_Phone?: string | null;
    questionOptionId_Trigger?: string;
    roleSpecificMappings?: ValueTupleOfGuidAndRoleAndGuid[] | null;
}

export interface ValueTupleOfGuidAndRoleAndGuid {
    item1?: string;
    item2?: Role;
    item3?: string;
}

export enum Role {
    Leader = 1,
    Follower = 2,
}

export interface Reduction extends Entity {
    registrableId?: string;
    registrable?: Registrable | null;
    registrableId1_ReductionActivatedIfCombinedWith?: string | null;
    registrable1_ReductionActivatedIfCombinedWith?: Registrable | null;
    registrableId2_ReductionActivatedIfCombinedWith?: string | null;
    registrable2_ReductionActivatedIfCombinedWith?: Registrable | null;
    amount?: number;
    onlyForRole?: Role | null;
    activatedByReduction?: boolean;
}

export interface Seat extends Entity {
    registrableId?: string;
    registrable?: Registrable | null;
    registrationId?: string | null;
    registration?: Registration | null;
    registrationId_Follower?: string | null;
    registration_Follower?: Registration | null;
    firstPartnerJoined?: Date;
    isCancelled?: boolean;
    isPartnerSpot?: boolean;
    isWaitingList?: boolean;
    partnerEmail?: string | null;
}

export interface Registration extends Entity {
    eventId?: string;
    event?: Event | null;
    registrationFormId?: string;
    registrationForm?: RegistrationForm | null;
    registrationId_Partner?: string | null;
    registration_Partner?: Registration | null;
    mails?: MailToRegistration[] | null;
    cancellations?: RegistrationCancellation[] | null;
    importedMails?: ImportedMailToRegistration[] | null;
    individualReductions?: IndividualReduction[] | null;
    paymentAssignments?: PaymentAssignment[] | null;
    responses?: Response[] | null;
    seats_AsFollower?: Seat[] | null;
    seats_AsLeader?: Seat[] | null;
    sms?: Sms[] | null;
    admittedAt?: Date | null;
    externalIdentifier?: string;
    externalTimestamp?: Date;
    fallbackToPartyPass?: boolean | null;
    isReduced?: boolean;
    isWaitingList?: boolean | null;
    language?: string | null;
    originalPrice?: number | null;
    partnerNormalized?: string | null;
    partnerOriginal?: string | null;
    phone?: string | null;
    phoneNormalized?: string | null;
    price?: number | null;
    receivedAt?: Date;
    remarks?: string | null;
    remarksProcessed?: boolean;
    reminderLevel?: number;
    respondentEmail?: string | null;
    respondentFirstName?: string | null;
    respondentLastName?: string | null;
    soldOutMessage?: string | null;
    state?: RegistrationState;
    willPayAtCheckin?: boolean;
}

export interface MailToRegistration extends Entity {
    mailId?: string;
    mail?: Mail | null;
    registrationId?: string;
    registration?: Registration | null;
    state?: MailState | null;
}

export enum MailState {
    Unknown = 0,
    Processed = 1,
    Dropped = 2,
    Delivered = 3,
    Deferred = 4,
    Bounce = 5,
    Open = 6,
    Click = 7,
    SpamReport = 8,
    Unsubscribe = 9,
    GroupUnsubscribe = 10,
    GroupResubscribe = 11,
}

export interface RegistrationCancellation extends Entity {
    registrationId?: string;
    registration?: Registration | null;
    created?: Date;
    reason?: string | null;
    refund?: number;
    refundPercentage?: number;
    received?: Date | null;
}

export interface ImportedMailToRegistration extends Entity {
    importedMailId?: string;
    mail?: ImportedMail | null;
    registrationId?: string;
    registration?: Registration | null;
}

export interface ImportedMail extends Entity {
    eventId?: string;
    event?: Event | null;
    registrations?: ImportedMailToRegistration[] | null;
    senderMail?: string | null;
    senderName?: string | null;
    subject?: string | null;
    recipients?: string | null;
    contentHtml?: string | null;
    contentPlainText?: string | null;
    date?: Date;
    imported?: Date;
    messageIdentifier?: string | null;
    sendGridMessageId?: string | null;
}

export interface IndividualReduction extends Entity {
    registrationId?: string;
    registration?: Registration | null;
    userId?: string;
    user?: User | null;
    amount?: number;
    reason?: string | null;
}

export interface PaymentAssignment extends Entity {
    registrationId?: string | null;
    registration?: Registration | null;
    incomingPaymentId?: string | null;
    incomingPayment?: IncomingPayment | null;
    outgoingPaymentId?: string | null;
    outgoingPayment?: OutgoingPayment | null;
    paymentAssignmentId_Counter?: string | null;
    paymentAssignment_Counter?: PaymentAssignment | null;
    payoutRequestId?: string | null;
    payoutRequest?: PayoutRequest | null;
    amount?: number;
    created?: Date | null;
}

export interface IncomingPayment extends Entity {
    payment?: Payment | null;
    debitorIban?: string | null;
    debitorName?: string | null;
    paymentSlipId?: string | null;
    paymentSlip?: PaymentSlip | null;
    assignments?: PaymentAssignment[] | null;
}

export interface Payment extends Entity {
    paymentsFileId?: string;
    paymentsFile?: PaymentsFile | null;
    currency?: string | null;
    amount?: number;
    charges?: number | null;
    bookingDate?: Date;
    info?: string | null;
    message?: string | null;
    instructionIdentification?: string | null;
    rawXml?: string | null;
    recognizedEmail?: string | null;
    reference?: string | null;
    repaid?: number | null;
    settled?: boolean;
    ignore?: boolean;
    incoming?: IncomingPayment | null;
    outgoing?: OutgoingPayment | null;
    type?: PaymentType;
}

export interface PaymentsFile extends Entity {
    eventId?: string | null;
    event?: Event | null;
    accountIban?: string | null;
    fileId?: string | null;
    balance?: number | null;
    bookingsFrom?: Date | null;
    bookingsTo?: Date | null;
    currency?: string | null;
    content?: string | null;
}

export interface OutgoingPayment extends Entity {
    payment?: Payment | null;
    creditorName?: string | null;
    creditorIban?: string | null;
    assignments?: PaymentAssignment[] | null;
}

export interface PaymentSlip extends Entity {
    eventId?: string;
    event?: Event | null;
    contentType?: string | null;
    fileBinary?: string | null;
    filename?: string | null;
    reference?: string | null;
}

export interface PayoutRequest extends Entity {
    registrationId?: string;
    registration?: Registration | null;
    assignments?: PaymentAssignment[] | null;
    amount?: number;
    reason?: string | null;
    created?: Date;
    state?: PayoutState;
}

export interface Response extends Entity {
    questionId?: string | null;
    question?: Question | null;
    registrationId?: string;
    registration?: Registration | null;
    questionOptionId?: string | null;
    questionOption?: QuestionOption | null;
    responseString?: string;
}

export interface Sms extends Entity {
    registrationId?: string | null;
    registration?: Registration | null;
    accountSid?: string | null;
    body?: string | null;
    error?: string | null;
    errorCode?: number | null;
    from?: string | null;
    price?: string | null;
    rawData?: string | null;
    received?: Date | null;
    sent?: Date | null;
    smsSid?: string | null;
    smsStatus?: string | null;
    to?: string | null;
    type?: SmsType;
}

export enum SmsType {
    Reminder = 1,
}

export interface MailTemplate extends Entity {
    eventId?: string;
    event?: Event | null;
    registrableId?: string | null;
    registrable?: Registrable | null;
    mails?: Mail[] | null;
    bulkMailKey?: string | null;
    contentType?: MailContentType;
    language?: string | null;
    mailingAudience?: MailingAudience | null;
    senderMail?: string | null;
    senderName?: string | null;
    subject?: string | null;
    template?: string | null;
    type?: MailType;
    isDeleted?: boolean;
    releaseImmediately?: boolean;
}

export enum MailContentType {
    Plaintext = 1,
    Html = 2,
}

export enum MailingAudience {
    Paid = 1,
    Unpaid = 2,
    WaitingList = 4,
    PredecessorEvent = 8,
    PrePredecessorEvent = 16,
}

export enum MailType {
    SingleRegistrationAccepted = 1,
    SingleRegistrationOnWaitingList = 2,
    RegistrationReceived = 3,
    PartnerRegistrationFirstPartnerAccepted = 11,
    PartnerRegistrationMatchedAndAccepted = 12,
    PartnerRegistrationFirstPartnerOnWaitingList = 13,
    PartnerRegistrationMatchedOnWaitingList = 14,
    SoldOut = 21,
    MoneyOwed = 22,
    TooMuchPaid = 23,
    RegistrationCancelled = 31,
    SingleRegistrationFullyPaid = 41,
    PartnerRegistrationFirstPaid = 42,
    PartnerRegistrationFullyPaid = 43,
    SingleRegistrationFirstReminder = 51,
    SingleRegistrationSecondReminder = 52,
    PartnerRegistrationFirstReminder = 61,
    PartnerRegistrationSecondReminder = 62,
    OptionsForRegistrationsOnWaitingList = 101,
}

export interface MailEvent extends Entity {
    mail?: Mail | null;
    mailId?: string;
    created?: Date;
    eMail?: string | null;
    externalIdentifier?: string | null;
    rawEvent?: string | null;
    state?: MailState;
}

export interface GetPendingMailsQuery {
    eventId?: string;
}

export interface MailDisplayItem {
    contentHtml?: string;
    created?: Date;
    events?: MailEventDisplayItem[];
    id?: string;
    recipients?: string;
    senderMail?: string;
    senderName?: string;
    state?: MailState | null;
    subject?: string;
    withhold?: boolean;
}

export interface MailEventDisplayItem {
    email?: string;
    state?: MailState;
    stateText?: string;
    when?: Date;
}

export interface MailsOfRegistrationQuery {
    eventId?: string;
    registrationId?: string;
}

export interface ReleaseAllPendingMailsCommand {
    eventId?: string;
}

export interface ReleaseMailCommand {
    eventId?: string;
    mailId?: string;
}

export interface DeleteMailTemplateCommand {
    eventId?: string;
    mailTemplateId?: string;
}

export interface LanguageItem {
    acronym?: string;
    userText?: string;
}

export interface LanguagesQuery {
    eventId?: string;
}

export interface MailTemplateItem {
    audience?: MailingAudience | null;
    id?: string;
    key?: string;
    language?: string;
    mailsReadyCount?: number;
    mailsSentCount?: number;
    senderMail?: string;
    senderName?: string;
    subject?: string;
    template?: string;
    type?: MailType | null;
    releaseImmediately?: boolean;
}

export interface MailTemplatesQuery {
    eventId?: string;
    templateGroup?: TemplateGroup;
}

export enum TemplateGroup {
    AutoGenerated = 1,
    BulkMail = 2,
}

export interface MailTypeItem {
    bulkMailKey?: string;
    type?: MailType | null;
    userText?: string;
}

export interface MailTypesQuery {
    eventId?: string;
}

export interface SaveMailTemplateCommand {
    eventId?: string;
    template?: MailTemplateItem;
    templateId?: string | null;
}

export interface SendMailCommand {
    contentHtml?: string;
    contentPlainText?: string;
    mailId?: string;
    sender?: EmailAddress;
    subject?: string;
    to?: EmailAddress[];
}

export interface EmailAddress {
    email?: string;
    name?: string;
}

export interface PossibleMailTypesQuery {
    eventId?: string;
    registrationId?: string;
}

export interface FixInvalidAddressCommand {
    eventId?: string;
    newEmailAddress?: string;
    oldEmailAddress?: string;
    registrationId?: string;
}

export interface InvalidAddress {
    email?: string;
    firstName?: string;
    lastMailSent?: Date | null;
    lastMailState?: string;
    lastName?: string;
    proposals?: string;
    registrationId?: string;
    registrationState?: string;
}

export interface InvalidAddressesQuery {
    eventId?: string;
}

export interface NotReceivedMail {
    created?: Date;
    events?: string;
    id?: string;
    recipients?: string;
    registrationId?: string;
    sent?: Date | null;
    state?: string;
    subject?: string;
}

export interface NotReceivedMailsQuery {
    eventId?: string;
}

export interface ImportMailsFromImapCommand {
    eventId?: string;
}

export interface ImportMailsFromImapForAllActiveEventsCommand {
}

export interface TryAssignImportedMailCommand {
    importedMailId?: string;
}

export interface ProcessMailEventsCommand {
    rawMailEventsId?: string;
}

export interface ComposeAndSendMailCommand {
    allowDuplicate?: boolean;
    bulkMailKey?: string;
    eventId?: string;
    mailType?: MailType | null;
    registrationId?: string;
    withhold?: boolean;
    data?: any;
}

export interface CreateBulkMailsCommand {
    bulkMailKey?: string;
    eventId?: string;
}

export interface PossibleAudience {
    audience?: MailingAudience;
    name?: string;
}

export interface PossibleAudiencesQuery {
    eventId?: string;
}

export interface ReleaseBulkMailsCommand {
    bulkMailKey?: string;
    eventId?: string;
}

export interface TranslationQuery {
    language?: string | null;
}

export interface DomainEventCatalogItem {
    typeName?: string | null;
    userText?: string;
}

export interface DomainEventCatalogQuery {
}

export interface DomainEventDisplayItem {
    timestamp?: Date | null;
    id?: string;
    type?: string;
    content?: string;
}

export interface DomainEventsQuery {
    eventId?: string;
    types?: string[];
}

export interface SaveDomainEventCommand {
    domainEventId?: string;
    domainEventId_Parent?: string | null;
    eventData?: string;
    eventId?: string | null;
    eventType?: string;
}

export interface StartUpdateAllReadModelsOfEventCommand {
    eventId?: string;
}

export interface UpdateReadModelCommand {
    queryName?: string;
    eventId?: string;
    rowId?: string | null;
    dirtyMoment?: Date;
}

export interface HostingOffers {
    dynamicColumns?: string[];
    offers?: HostingOffer[];
}

export interface HostingOffer {
    admittedAt?: Date | null;
    columns?: { [key: string]: string; };
    email?: string;
    firstName?: string;
    language?: string;
    lastName?: string;
    phone?: string;
    registrationId?: string;
    state?: string;
}

export interface HostingOffersQuery {
    eventId?: string;
}

export interface HostingRequests {
    dynamicColumns?: string[];
    requests?: HostingRequest[];
}

export interface HostingRequest {
    admittedAt?: Date | null;
    columns?: { [key: string]: string; };
    email?: string;
    firstName?: string;
    language?: string;
    lastName?: string;
    phone?: string;
    registrationId?: string;
    state?: string;
}

export interface HostingRequestsQuery {
    eventId?: string;
}

export interface CreateEventCommand {
    acronym?: string;
    eventId_CopyFrom?: string | null;
    id?: string;
    name?: string;
}

export interface EventDetails {
    id?: string;
    name?: string;
    acronym?: string;
    state?: State;
}

export interface EventQuery {
    eventId?: string;
}

export interface OpenRegistrationCommand {
    deleteTestData?: boolean;
    eventId?: string;
}

export interface EventSearchResult {
    acronym?: string;
    id?: string;
    name?: string;
    requestSent?: boolean;
    state?: State;
}

export interface SearchEventQuery {
    includeAuthorizedEvents?: boolean;
    includeRequestedEvents?: boolean;
    searchString?: string | null;
}

export interface AddUserToRoleInEventCommand {
    eventId?: string;
    role?: UserInEventRole;
    userId?: string;
}

export interface UserInEventDisplayItem {
    eventAcronym?: string;
    eventId?: string;
    eventName?: string;
    eventState?: State;
    requestSent?: boolean;
    role?: UserInEventRole;
    userEmail?: string;
    userFirstName?: string;
    userId?: string;
    userLastName?: string;
}

export interface EventsOfUserQuery {
    includeRequestedEvents?: boolean;
}

export interface RemoveUserFromRoleInEventCommand {
    eventId?: string;
    role?: UserInEventRole;
    userId?: string;
}

export interface UsersOfEventQuery {
    eventId?: string;
}

export interface AccessRequestOfEvent {
    email?: string;
    firstName?: string;
    id?: string;
    lastName?: string;
    requestReceived?: Date;
    requestText?: string;
}

export interface AccessRequestsOfEventQuery {
    eventId?: string;
    includeDeniedRequests?: boolean;
}

export interface RequestAccessCommand {
    eventId?: string;
    requestText?: string;
}

export interface RespondToRequestCommand {
    accessToEventRequestId?: string;
    eventId?: string;
    response?: RequestResponse;
    responseText?: string;
    role?: UserInEventRole;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}